/*
 *
  ***** BEGIN LICENSE BLOCK *****
 
  Copyright (C) 2009-2016 Olof Hagsand and Benny Holmgren
  Copyright (C) 2017-2019 Olof Hagsand
  Copyright (C) 2020 Olof Hagsand and Rubicon Communications, LLC

  This file is part of CLIXON.

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.

  Alternatively, the contents of this file may be used under the terms of
  the GNU General Public License Version 3 or later (the "GPL"),
  in which case the provisions of the GPL are applicable instead
  of those above. If you wish to allow use of your version of this file only
  under the terms of the GPL, and not to allow others to
  use your version of this file under the terms of Apache License version 2, 
  indicate your decision by deleting the provisions above and replace them with
  the  notice and other provisions required by the GPL. If you do not delete
  the provisions above, a recipient may use your version of this file under
  the terms of any one of the Apache License version 2 or the GPL.

  ***** END LICENSE BLOCK *****

 *
 * Translation / mapping code between formats
 */
#ifdef HAVE_CONFIG_H
#include "clixon_config.h" /* generated by config & autoconf */
#endif

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include <ctype.h>
#include <string.h>
#include <syslog.h>
#include <fcntl.h>
#include <assert.h>
#include <arpa/inet.h>
#include <sys/param.h>
#include <netinet/in.h>

/* cligen */
#include <cligen/cligen.h>

/* clicon */

#include "clixon_string.h"
#include "clixon_queue.h"
#include "clixon_hash.h"
#include "clixon_handle.h"
#include "clixon_string.h"
#include "clixon_yang.h"
#include "clixon_xml.h"
#include "clixon_options.h"
#include "clixon_data.h"
#include "clixon_yang_module.h"
#include "clixon_plugin.h"
#include "clixon_xml_nsctx.h"
#include "clixon_xpath_ctx.h"
#include "clixon_xpath.h"
#include "clixon_log.h"
#include "clixon_err.h"
#include "clixon_netconf_lib.h"
#include "clixon_xml_sort.h"
#include "clixon_yang_type.h"
#include "clixon_xml_map.h"

/*! Is attribute and is either of form xmlns="", or xmlns:x="" */
int
isxmlns(cxobj *x)
{
    char *prefix = NULL;

    if (xml_type(x) != CX_ATTR)
	return 0;
    if (strcmp(xml_name(x), "xmlns")==0)
	return 1;
    if ((prefix = xml_prefix(x)) != NULL
	&& strcmp(xml_prefix(x), "xmlns")==0)
	return 1;
    return 0;
}

/*! x is element and has eactly one child which in turn has none 
 * @see child_type in clixon_json.c
 */
static int
tleaf(cxobj *x)
{
    cxobj *xc;

    if (xml_type(x) != CX_ELMNT)
	return 0;
    if (xml_child_nr_notype(x, CX_ATTR) != 1)
	return 0;
    /* From here exactly one noattr child, get it */
    xc = NULL;
    while ((xc = xml_child_each(x, xc, -1)) != NULL)
	if (xml_type(xc) != CX_ATTR)
	    break;
    if (xc == NULL)
	return -1; /* n/a */
    return (xml_child_nr_notype(xc, CX_ATTR) == 0);
}

/*! Translate XML -> TEXT
 * @param[in]  level  print 4 spaces per level in front of each line
 * XXX rewrite using YANG and remove encrypted password KLUDGE
 */
int 
xml2txt(FILE  *f, 
	cxobj *x, 
	int    level)
{
    cxobj *xc = NULL;
    int    children=0;
    int    retval = -1;

    xc = NULL;     /* count children (elements and bodies, not attributes) */
    while ((xc = xml_child_each(x, xc, -1)) != NULL)
	if (xml_type(xc) == CX_ELMNT || xml_type(xc) == CX_BODY)
	    children++;
    if (!children){ /* If no children print line */
	switch (xml_type(x)){
	case CX_BODY:
	    fprintf(f, "%s;\n", xml_value(x));
	    break;
	case CX_ELMNT:
	    fprintf(f, "%*s;\n", 4*level, xml_name(x));
	    break;
	default:
	    break;
	}
	goto ok;
    }
    fprintf(f, "%*s", 4*level, "");
    fprintf(f, "%s ", xml_name(x));
    if (!tleaf(x))
	fprintf(f, "{\n");
    xc = NULL;
    while ((xc = xml_child_each(x, xc, -1)) != NULL){
	if (xml_type(xc) == CX_ELMNT || xml_type(xc) == CX_BODY)
	    if (xml2txt(f, xc, level+1) < 0)
		break;
    }
    if (!tleaf(x))
	fprintf(f, "%*s}\n", 4*level, "");
 ok:
    retval = 0;
    //  done:
    return retval;
}

/*! Translate from XML to CLI commands
 * Howto: join strings and pass them down. 
 * Identify unique/index keywords for correct set syntax.
 * Args:
 *  @param[in] f        Where to print cli commands
 *  @param[in] x        XML Parse-tree (to translate)
 *  @param[in] prepend0 Print this text in front of all commands.
 *  @param[in] gt       option to steer cli syntax
 */
int 
xml2cli(FILE              *f, 
	cxobj             *x, 
	char              *prepend0, 
	enum genmodel_type gt)
{
    int              retval = -1;
    cxobj           *xe = NULL;
    cbuf            *cbpre = NULL;
    yang_stmt       *ys;
    int              match;
    char            *body;

    if (xml_type(x)==CX_ATTR)
	goto ok;
    if ((ys = xml_spec(x)) == NULL)
	goto ok;
    if (yang_keyword_get(ys) == Y_LEAF || yang_keyword_get(ys) == Y_LEAF_LIST){
	if (prepend0)
	    fprintf(f, "%s", prepend0);
	if (gt == GT_ALL || gt == GT_VARS)
	    fprintf(f, "%s ", xml_name(x));
	if ((body = xml_body(x)) != NULL){
	    if (index(body, ' '))
		fprintf(f, "\"%s\"", body);
	    else
		fprintf(f, "%s", body);
	}
	fprintf(f, "\n");
	goto ok;
    }
    /* Create prepend variable string */
    if ((cbpre = cbuf_new()) == NULL){
	clicon_err(OE_PLUGIN, errno, "cbuf_new");	
	goto done;
    }
    if (prepend0)
	cprintf(cbpre, "%s", prepend0);
    cprintf(cbpre, "%s ", xml_name(x));

    if (yang_keyword_get(ys) == Y_LIST){
	/* If list then first loop through keys */
	xe = NULL;
	while ((xe = xml_child_each(x, xe, -1)) != NULL){
	    if ((match = yang_key_match(ys, xml_name(xe))) < 0)
		goto done;
	    if (!match)
		continue;
	    if (gt == GT_ALL)
		cprintf(cbpre, "%s ", xml_name(xe));
	    cprintf(cbpre, "%s ", xml_body(xe));
	}
    }
    /* Then loop through all other (non-keys) */
    xe = NULL;
    while ((xe = xml_child_each(x, xe, -1)) != NULL){
	if (yang_keyword_get(ys) == Y_LIST){
	    if ((match = yang_key_match(ys, xml_name(xe))) < 0)
		goto done;
	    if (match){
		fprintf(f, "%s\n", cbuf_get(cbpre));	
		continue; /* Not key itself */
	    }
	}
	if (xml2cli(f, xe, cbuf_get(cbpre), gt) < 0)
	    goto done;
    }
 ok:
    retval = 0;
  done:
    if (cbpre)
	cbuf_free(cbpre);
    return retval;
}

/*! Translate a single xml node to a cligen variable vector. Note not recursive 
 * @param[in]  xt   XML tree containing one top node
 * @param[in]  ys   Yang spec containing type specification of top-node of xt
 * @param[out] cvv  CLIgen variable vector. Should be freed by cvec_free()
 * @retval     0    Everything OK, cvv allocated and set
 * @retval    -1    Something wrong, clicon_err() called to set error. No cvv returned
 * @note  cvv Should be freed by cvec_free() after use.
 * 'Not recursive' means that only one level of XML bodies is translated to cvec:s.
 * If range is wriong (eg 1000 for uint8) a warning is logged, the value is 
 * skipped, and continues.
 * yang is needed to know which type an xml element has.
 * Example: 
    <a>
      <b>23</b>
      <c>88</c>
      <d>      
        <e>99</e>
      </d>
    </a> 
         --> b:23, c:88
 * @see cvec2xml
 */
int
xml2cvec(cxobj      *xt, 
	 yang_stmt  *yt, 
	 cvec      **cvv0)
{
    int               retval = -1;
    cvec             *cvv = NULL;
    cxobj            *xc;         /* xml iteration variable */
    yang_stmt        *ys;         /* yang spec */
    cg_var           *cv;
    cg_var           *ycv;
    char             *body;
    char             *reason = NULL;
    int               ret;
    char             *name;

    xc = NULL;
    /* Tried to allocate whole cvv here, but some cg_vars may be invalid */
    if ((cvv = cvec_new(0)) == NULL){
	clicon_err(OE_UNIX, errno, "cvec_new");
	goto err;
    }
    xc = NULL;
    /* Go through all children of the xml tree */
    while ((xc = xml_child_each(xt, xc, CX_ELMNT)) != NULL){
	name = xml_name(xc);
	if ((ys = yang_find_datanode(yt, name)) == NULL){
	    clicon_debug(0, "%s: yang sanity problem: %s in xml but not present in yang under %s",
			 __FUNCTION__, name, yang_argument_get(yt));
	    if ((body = xml_body(xc)) != NULL){
		if ((cv = cv_new(CGV_STRING)) == NULL){
		    clicon_err(OE_PLUGIN, errno, "cv_new");
		    goto err;
		}
		cv_name_set(cv, name);
		if ((ret = cv_parse1(body, cv, &reason)) < 0){
		    clicon_err(OE_PLUGIN, errno, "cv_parse %s",name);
		    goto err;
		}
		/* If value is out-of-range, log and skip value, and continue */
		if (ret == 0){
		    clicon_log(LOG_WARNING, "cv_parse %s: %s", name, reason); 
		    if (reason)
			free(reason);
		}
		else
		    cvec_append_var(cvv, cv); /* Add to variable vector */
		cv_free(cv);
	    }
	}
	else if ((ycv = yang_cv_get(ys)) != NULL){
	    if ((body = xml_body(xc)) != NULL){
		if ((cv = cv_new(CGV_STRING)) == NULL){
		    clicon_err(OE_PLUGIN, errno, "cv_new");
		    goto err;
		}
		if (cv_cp(cv, ycv) < 0){
		    clicon_err(OE_PLUGIN, errno, "cv_cp");
		    goto err;
		}
		if ((ret = cv_parse1(body, cv, &reason)) < 0){
		    clicon_err(OE_PLUGIN, errno, "cv_parse: %s", name);
		    goto err;
		}
		if (ret == 0){
		    clicon_log(LOG_WARNING, "cv_parse %s: %s", name, reason);
		    if (reason)
			free(reason);
		}
		else
		    cvec_append_var(cvv, cv); /* Add to variable vector */
		cv_free(cv);
	    }
	}
    }
    if (debug > 1){
	clicon_debug(2, "%s cvv:\n", __FUNCTION__);
	cvec_print(stderr, cvv);
    }
    *cvv0 = cvv;
    return 0;
 err:
    if (cvv)
	cvec_free(cvv);
    return retval;
}

/*! Translate a cligen variable vector to an XML tree with depth one 
 * @param[in]   cvv  CLIgen variable vector. Should be freed by cvec_free()
 * @param[in]   toptag    The XML tree in xt will have this XML tag
 * @param[in]   xt   Parent, or NULL
 * @param[out]  xt   Pointer to XML tree containing one top node. Should be freed with xml_free
 * @retval      0    Everything OK, cvv allocated and set
 * @retval     -1    Something wrong, clicon_err() called to set error. No xt returned
 * @see xml2cvec
 * @see cvec2xml   This does more but has an internal xml2cvec translation
*/
int
cvec2xml_1(cvec   *cvv, 
	   char   *toptag, 
	   cxobj  *xp,
	   cxobj **xt0)
{
    int               retval = -1;
    cxobj            *xt = NULL;
    cxobj            *xn;
    cxobj            *xb;
    cg_var           *cv;
    char             *val;
    int               len=0;
    int               i;

    cv = NULL;
    while ((cv = cvec_each(cvv, cv)) != NULL) 
	len++;
    if ((xt = xml_new(toptag, xp, NULL)) == NULL)
	goto err;
    if (xml_childvec_set(xt, len) < 0)
	goto err;
    cv = NULL;
    i = 0;
    while ((cv = cvec_each(cvv, cv)) != NULL) {
	if (cv_type_get(cv)==CGV_ERR || cv_name_get(cv) == NULL)
	    continue;
	if ((xn = xml_new(cv_name_get(cv), NULL, NULL)) == NULL) /* this leaks */
	    goto err;
	xml_parent_set(xn, xt);
	xml_child_i_set(xt, i++, xn);
	if ((xb = xml_new("body", xn, NULL)) == NULL) /* this leaks */
	    goto err;
	xml_type_set(xb, CX_BODY);
	val = cv2str_dup(cv);
	xml_value_set(xb, val); /* this leaks */
	if (val)
	    free(val);
    }
    *xt0 = xt;
    return 0;
 err:
    if (xt)
	xml_free(xt);
    return retval;
}

/*! Recursive help function to compute differences between two xml trees
 * @param[in]  x0         First XML tree
 * @param[in]  x1         Second XML tree
 * @param[out] x0vec      Pointervector to XML nodes existing in only first tree
 * @param[out] x0veclen   Length of first vector
 * @param[out] x1vec      Pointervector to XML nodes existing in only second tree
 * @param[out] x1veclen   Length of x1vec vector
 * @param[out] changed_x0 Pointervector to XML nodes changed orig value
 * @param[out] changed_x1 Pointervector to XML nodes changed wanted value
 * @param[out] changedlen Length of changed vector
 * Algorithm to compare two sorted lists A, B:
 *   A 0 1 2 3 5 6
 *   B 0 2 4 5 6
 * Let (a, b) be first elements of (A, B) respectively(*)
 *   a = b :  EITHER leafs: a!=b : add a in changed_x0, b in changed_x1,
 *            OR: Set (A,B) to children of (a,b) and call algorithm recursively
 *         , get next (a,b)
 *   a < b : add a in x0, get next a 
 *   a > b : add b in x1, get next b
 * (*) "comparing" a&b here is made by xml_cmp() which judges equality from a structural
 *     perspective, ie both have the same yang spec, if they are lists, they have the
 *     the same keys. NOT that the values are equal!
 * @see xml_diff  API function, this one is internal and recursive
 */
static int
xml_diff1(yang_stmt *ys, 
	  cxobj     *x0, 
	  cxobj     *x1,
	  cxobj   ***x0vec,
	  size_t    *x0veclen,
	  cxobj   ***x1vec,
	  size_t    *x1veclen,
	  cxobj   ***changed_x0,
	  cxobj   ***changed_x1,
	  size_t    *changedlen)
{
    int        retval = -1;
    cxobj     *x0c = NULL; /* x0 child */
    cxobj     *x1c = NULL; /* x1 child */
    yang_stmt *yc;
    char      *b1;
    char      *b2;
    int        eq;

    /* Traverse x0 and x1 in lock-step */
    x0c = x1c = NULL;    
    x0c = xml_child_each(x0, x0c, CX_ELMNT);
    x1c = xml_child_each(x1, x1c, CX_ELMNT);
    for (;;){
	if (x0c == NULL && x1c == NULL)
	    goto ok;
	else if (x0c == NULL){
	    if (cxvec_append(x1c, x1vec, x1veclen) < 0) 
		goto done;
	    x1c = xml_child_each(x1, x1c, CX_ELMNT);
	    continue;
	}
	else if (x1c == NULL){
	    if (cxvec_append(x0c, x0vec, x0veclen) < 0) 
		goto done;
	    x0c = xml_child_each(x0, x0c, CX_ELMNT);
	    continue;
	}
	/* Both x0c and x1c exists, check if they are equal. */
	eq = xml_cmp(x0c, x1c, 0, 0);
	if (eq < 0){
	    if (cxvec_append(x0c, x0vec, x0veclen) < 0) 
		goto done;
	    x0c = xml_child_each(x0, x0c, CX_ELMNT);
	    continue;
	}
	else if (eq > 0){
	    if (cxvec_append(x1c, x1vec, x1veclen) < 0) 
		goto done;
	    x1c = xml_child_each(x1, x1c, CX_ELMNT);
	    continue;
	}
	else{ /* equal */
	    if ((yc = xml_spec(x0c)) == NULL){
		clicon_err(OE_UNIX, errno, "Unknown element: %s", xml_name(x0c));
		goto done;
	    }
	    if (yang_choice(yc)){
		/* if x0c and x1c are choice/case, then they are changed */
		if (cxvec_append(x0c, changed_x0, changedlen) < 0) 
		    goto done;
		(*changedlen)--; /* append two vectors */
		if (cxvec_append(x1c, changed_x1, changedlen) < 0) 
		    goto done;
	    }
	    else if (yang_keyword_get(yc) == Y_LEAF){
		/* if x0c and x1c are leafs w bodies, then they are changed */
		if ((b1 = xml_body(x0c)) == NULL) /* empty type */
		    break;
		if ((b2 = xml_body(x1c)) == NULL) /* empty type */
		    break;
		if (strcmp(b1, b2)){
		    if (cxvec_append(x0c, changed_x0, changedlen) < 0) 
			goto done;
		    (*changedlen)--; /* append two vectors */
		    if (cxvec_append(x1c, changed_x1, changedlen) < 0) 
			goto done;
		}
	    }
	    else if (xml_diff1(yc, x0c, x1c,   
			       x0vec, x0veclen, 
			       x1vec, x1veclen, 
			       changed_x0, changed_x1, changedlen)< 0)
		goto done;
	}
	x0c = xml_child_each(x0, x0c, CX_ELMNT);
	x1c = xml_child_each(x1, x1c, CX_ELMNT);
    }
 ok:
    retval = 0;
 done:
    return retval;
}

/*! Compute differences between two xml trees
 * @param[in]  yspec      Yang specification
 * @param[in]  x0         First XML tree
 * @param[in]  x1         Second XML tree
 * @param[out] first      Pointervector to XML nodes existing in only first tree
 * @param[out] firstlen   Length of first vector
 * @param[out] second     Pointervector to XML nodes existing in only second tree
 * @param[out] secondlen  Length of second vector
 * @param[out] changed_x0 Pointervector to XML nodes changed orig value
 * @param[out] changed_x1 Pointervector to XML nodes changed wanted value
 * @param[out] changedlen Length of changed vector
 * All xml vectors should be freed after use.
 */
int
xml_diff(yang_stmt *yspec, 
	 cxobj     *x0, 
	 cxobj     *x1,
	 cxobj   ***first,
	 size_t    *firstlen,
	 cxobj   ***second,
	 size_t    *secondlen,
	 cxobj   ***changed_x0,
	 cxobj   ***changed_x1,
	 size_t    *changedlen)
{
    int retval = -1;

    *firstlen = 0;
    *secondlen = 0;    
    *changedlen = 0;
    if (x0 == NULL && x1 == NULL)
	return 0;
    if (x1 == NULL){
	if (cxvec_append(x0, first, firstlen) < 0) 
	    goto done;
	goto ok;
    }
    if (x0 == NULL){
	if (cxvec_append(x0, second, secondlen) < 0) 
	    goto done;
	goto ok;
    }
    if (xml_diff1((yang_stmt*)yspec, x0, x1,
		  first, firstlen, 
		  second, secondlen, 
		  changed_x0, changed_x1, changedlen) < 0)
	goto done;
 ok:
    retval = 0;
 done:
    return retval;
}

/*! Prune everything that does not pass test or have at least a child* does not
 * @param[in]   xt      XML tree with some node marked
 * @param[in]   flag    Which flag to test for
 * @param[in]   test    1: test that flag is set, 0: test that flag is not set
 * @param[out]  upmark  Set if a child (recursively) has marked set.
 * The function removes all branches that does not pass the test
 * Purge all nodes that dont have MARK flag set recursively.
 * Save all nodes that is MARK:ed or have at least one (grand*)child that is MARKed
 * @code
 *    xml_tree_prune_flagged_sub(xt, XML_FLAG_MARK, 1, NULL);
 * @endcode
 * @note This function seems a little too complex semantics
 * @see xml_tree_prune_flagged for a simpler variant
 */
int
xml_tree_prune_flagged_sub(cxobj *xt, 
			   int    flag,
			   int    test,
			   int   *upmark)
{
    int        retval = -1;
    int        submark;
    int        mark;
    cxobj     *x;
    cxobj     *xprev;
    int        iskey;
    int        anykey=0;
    yang_stmt *yt;
    int        i;

    mark = 0;
    yt = xml_spec(xt); /* xan be null */
    x = NULL;
    xprev = x = NULL;
    i = 0;
    while ((x = xml_child_each(xt, x, -1)) != NULL) {
	i++;
	if (xml_type(x) != CX_ELMNT){
	    xprev = x;
	    continue;
	}
	if (xml_flag(x, flag) == test?flag:0){
	    /* Pass test */
	    mark++;
	    xprev = x;
	    continue; /* mark and stop here */
	}
	/* If it is key dont remove it yet (see second round) */
	if (yt){
	    if ((iskey = yang_key_match(yt, xml_name(x))) < 0)
		goto done;
	    if (iskey){
		anykey++;
		xprev = x; /* skip if this is key */
		continue;
	    }
	}
	if (xml_tree_prune_flagged_sub(x, flag, test, &submark) < 0)
	    goto done;
	/* if xt is list and submark anywhere, then key subs are also marked
	 */
	if (submark)
	    mark++;
	else{ /* Safe with xml_child_each if last */
	    if (xml_child_rm(xt, i-1) < 0)
		goto done;
	    i--;
	    x = xprev;
	}
	xprev = x;
    }
    /* Second round: if any keys were found, and no marks detected, purge now */
    if (anykey && !mark){
	x = NULL;
	xprev = x = NULL;
	i = 0;
	while ((x = xml_child_each(xt, x, -1)) != NULL) {
	    i++;
	    if (xml_type(x) != CX_ELMNT){
		xprev = x;
		continue;
	    }
	    /* If it is key remove it here */
	    if (yt){
		if ((iskey = yang_key_match(yt, xml_name(x))) < 0)
		    goto done;
		if (xml_child_rm(xt, i-1) < 0)
		    goto done;
		i--;
		x = xprev;
	    }
	    xprev = x; 
	}
    }
    retval = 0;
 done:
    if (upmark)
	*upmark = mark;
    return retval;
}

/*! Prune everything that passes test
 * @param[in]   xt      XML tree with some node marked
 * @param[in]   flag    Which flag to test for
 * @param[in]   test    1: test that flag is set, 0: test that flag is not set
 * The function removes all branches that does not pass test
 * @code
 *    xml_tree_prune_flagged(xt, XML_FLAG_MARK, 1);
 * @endcode
 */
int
xml_tree_prune_flagged(cxobj *xt, 
		       int    flag,
		       int    test)
{
    int        retval = -1;
    cxobj     *x;
    cxobj     *xprev;

    x = NULL;
    xprev = NULL;
    while ((x = xml_child_each(xt, x, CX_ELMNT)) != NULL) {
	if (xml_flag(x, flag) == test?flag:0){ 	/* Pass test means purge */
	    if (xml_purge(x) < 0)
		goto done;
	    x = xprev;
	    continue; 
	}
	if (xml_tree_prune_flagged(x, flag, test) < 0)
	    goto done;
	xprev = x;
    }
    retval = 0;
 done:
    return retval;
}

/*! Add prefix:namespace pair to xml node, set cache, prefix, etc
 */
static int
add_namespace(cxobj *x1, /* target */
	      char  *prefix1,
	      char  *namespace)
{
    int    retval = -1;
    cxobj *xa = NULL;
    
    /* Add binding to x1p. We add to parent due to heurestics, so we dont
     * end up in adding it to large number of siblings 
     */
    if (nscache_set(x1, prefix1, namespace) < 0)
	goto done;
    /* Create xmlns attribute to x1p/x1 XXX same code v */
    if (prefix1){
	if ((xa = xml_new(prefix1, x1, NULL)) == NULL)
	    goto done;
	if (xml_prefix_set(xa, "xmlns") < 0)
	    goto done;
    }
    else{
	if ((xa = xml_new("xmlns", x1, NULL)) == NULL)
	    goto done;
    }
    xml_type_set(xa, CX_ATTR);
    if (xml_value_set(xa, namespace) < 0)
	goto done;
    xml_sort(x1, NULL); /* Ensure attr is first / XXX xml_insert? */
	
    /* 5. Add prefix to x1, if any */
    if (prefix1 && xml_prefix_set(x1, prefix1) < 0)
	goto done;
    retval = 0;
 done:
    return retval;
}

/*! Change namespace of XML node 
 *
 * @param[in]  x         XML node
 * @param[in]  namespace Change to this namespace (if ns does not exist in tree)
 * @param[in]  prefix    If change, use this prefix
 * @param      0         OK
 * @param     -1         Error
 */
int
xml_namespace_change(cxobj *x, 
                    char   *namespace,
                    char   *prefix)
{
    int    retval = -1;
    char  *ns0 = NULL;     /* existing namespace */
    char  *prefix0 = NULL; /* existing prefix */
    
    ns0 = NULL;
    if (xml2ns(x, xml_prefix(x), &ns0) < 0)
       goto done;
    if (ns0 && strcmp(ns0, namespace) == 0)
       goto ok; /* Already has right namespace */ 
    /* Is namespace already declared? */
    if (xml2prefix(x, namespace, &prefix0) == 1){
       /* Yes it is declared and the prefix is pexists */
       if (xml_prefix_set(x, prefix0) < 0)
           goto done;
    }
    else{ /* Namespace does not exist, add it */
	/* Clear old prefix if any */
       if (xml_prefix_set(x, NULL) < 0)
           goto done;
       if (add_namespace(x, prefix0, namespace) < 0)
	   goto done;	   
    }
 ok:
    retval = 0;
 done:
    return retval;
}

/*! Add default values (if not set)
 * @param[in]   xt      XML tree with some node marked
 * @param[in]   arg     Ignored
 * Typically called in a recursive apply function:
 * @code
 *   xml_apply(xt, CX_ELMNT, xml_default, NULL);
 * @endcode
 */
int
xml_default(cxobj *xt, 
	    void   *arg)
{
    int        retval = -1;
    yang_stmt *ys;
    yang_stmt *y;
    //    int        i; // XXX
    cxobj     *xc;
    cxobj     *xb;
    char      *str;
    int        added=0;
    char      *namespace;
    char      *prefix;
    int        ret;
    
    if ((ys = (yang_stmt*)xml_spec(xt)) == NULL){
	retval = 0;
	goto done;
    }
    /* Check leaf defaults */
    if (yang_keyword_get(ys) == Y_CONTAINER || yang_keyword_get(ys) == Y_LIST ||
	yang_keyword_get(ys) == Y_INPUT){
	y = NULL;
	while ((y = yn_each(ys, y)) != NULL) {
	    if (yang_keyword_get(y) != Y_LEAF)
		continue;
	    if (!cv_flag(yang_cv_get(y), V_UNSET)){  /* Default value exists */
		if (!xml_find(xt, yang_argument_get(y))){
		    if ((xc = xml_new(yang_argument_get(y), NULL, y)) == NULL)
			goto done;
		    /* assign right prefix */
		    if ((namespace = yang_find_mynamespace(y)) != NULL){
			prefix = NULL;
			if ((ret = xml2prefix(xt, namespace, &prefix)) < 0)
			    goto done;
			if (ret){
			    if (xml_prefix_set(xc, prefix) < 0)
				goto done;
			}
			else{ /* namespace does not exist in target, use source prefix */
			    if ((prefix = yang_find_myprefix(y)) == NULL){
				clicon_err(OE_UNIX, errno, "strdup");
				goto done;
			    }
			    if (add_namespace(xc, prefix, namespace) < 0)
				goto done;
			}
		    }

		    xml_flag_set(xc, XML_FLAG_DEFAULT);
		    if ((xb = xml_new("body", xc, NULL)) == NULL)
			goto done;
		    xml_type_set(xb, CX_BODY);
		    if ((str = cv2str_dup(yang_cv_get(y))) == NULL){
			clicon_err(OE_UNIX, errno, "cv2str_dup");
			goto done;
		    }
		    if (xml_value_set(xb, str) < 0)
			goto done;
		    free(str);
		    added++;
		    if (xml_insert(xt, xc, INS_LAST, NULL, NULL) < 0)
			goto done;
		}
	    }
	}
    }
    retval = 0;
 done:
    return retval;
}

/*! Sanitize an xml tree: xml node has matching yang_stmt pointer 
 * @param[in]   xt      XML top of tree
 */
int
xml_sanity(cxobj *xt, 
	   void  *arg)
{
    int        retval = -1;
    yang_stmt *ys;
    char      *name;

    if ((ys = (yang_stmt*)xml_spec(xt)) == NULL){
	retval = 0;
	goto done;
    }
    name = xml_name(xt);
    if (strstr(yang_argument_get(ys), name)==NULL){
	clicon_err(OE_XML, 0, "xml node name '%s' does not match yang spec arg '%s'", 
		   name, yang_argument_get(ys));
	goto done;
    }
    retval = 0;
 done:
    return retval;
}

/*! Mark all nodes that are not configure data and set return
 * @param[in]   xt      XML tree 
 * @param[out]  arg     If set, set to 1 as int* if not config data
 */
int
xml_non_config_data(cxobj *xt, 
		    void   *arg) /* Set to 1 if state node */
{
    int        retval = -1;
    yang_stmt *ys;

    if ((ys = (yang_stmt*)xml_spec(xt)) == NULL){
	retval = 0;
	goto done;
    }
    if (!yang_config(ys)){ /* config == false means state data: mark for remove */
	xml_flag_set(xt, XML_FLAG_MARK);
	if (arg)
	    (*(int*)arg) = 1;
    }
    retval = 0;
 done:
    return retval;
}

/*! Find yang spec association of XML node for incoming RPC starting with <rpc>
 * 
 * Incoming RPC has an "input" structure that is not taken care of by xml_spec_populate
 * @param[in]   xrpc XML rpc node
 * @param[in]   yspec  Yang spec
 * @param[out]  xerr   Reason for failure, or NULL
 * @retval      1      OK yang assignment made
 * @retval      0      Partial or no yang assigment made (at least one failed) and xerr set
 * @retval     -1      Error
 * The 
 * @code
 *   if (xml_spec_populate_rpc(h, x, NULL) < 0)
 *      err;
 * @endcode
 * @see xml_spec_populate  For other generic cases
 * @see xml_spec_populate_rpc_reply
 */
int
xml_spec_populate_rpc(cxobj     *xrpc,
		      yang_stmt *yspec,
		      cxobj    **xerr)
{
    int        retval = -1;
    yang_stmt *yrpc = NULL;    /* yang node */
    yang_stmt *ymod=NULL; /* yang module */
    yang_stmt *yi = NULL; /* input */
    cxobj     *x;
    int        ret;
    
    if ((strcmp(xml_name(xrpc), "rpc")) != 0){
	clicon_err(OE_UNIX, EINVAL, "RPC expected");
	goto done;
    }
    x = NULL;
    while ((x = xml_child_each(xrpc, x, CX_ELMNT)) != NULL) {
	if (ys_module_by_xml(yspec, x, &ymod) < 0)
	    goto done;
	if (ymod != NULL)
	    yrpc = yang_find(ymod, Y_RPC, xml_name(x));
	/* Non-strict semantics: loop through all modules to find the node 
	 */
	if (yrpc){
	    xml_spec_set(x, yrpc);
	    if ((yi = yang_find(yrpc, Y_INPUT, NULL)) != NULL){
		/* xml_spec_populate need to have parent with yang spec for
		 * recursive population to work. Therefore, assign input yang
		 * to rpc level although not 100% intuitive */
		xml_spec_set(x, yi); 
		if ((ret = xml_spec_populate_parent(x, xerr)) < 0)
		    goto done;
		if (ret == 0)
		    goto fail;
	    }
	}
    }
    retval = 1;
 done:
    return retval;
 fail:
    retval = 0;
    goto done;
}

/*! Find yang spec association of XML node for outgoing RPC starting with <rpc-reply>
 * 
 * Incoming RPC has an "input" structure that is not taken care of by xml_spec_populate
 * @param[in]   xrpc  XML rpc node
 * @param[in]   name  Name of RPC (not seen in output/reply)
 * @param[in]   yspec  Yang spec
 * @param[out]  xerr   Reason for failure, or NULL
 * @retval      1      OK yang assignment made
 * @retval      0      Partial or no yang assigment made (at least one failed) and xerr set
 * @retval     -1      Error
 *
 * @code
 *   if (xml_spec_populate_rpc_reply(x, "get-config", yspec, name) < 0)
 *      err;
 * @endcode
 * @see xml_spec_populate  For other generic cases
 */
int
xml_spec_populate_rpc_reply(cxobj     *xrpc,
			    char      *name,
			    yang_stmt *yspec,
			    cxobj    **xerr)
{
    int        retval = -1;
    yang_stmt *yrpc = NULL;    /* yang node */
    yang_stmt *ymod=NULL;      /* yang module */
    yang_stmt *yo = NULL;      /* output */
    cxobj     *x;
    int        ret;
    
    if (strcmp(xml_name(xrpc), "rpc-reply")){
	clicon_err(OE_UNIX, EINVAL, "rpc-reply expected");
	goto done;
    }
    x = NULL;
    while ((x = xml_child_each(xrpc, x, CX_ELMNT)) != NULL) {
	if (ys_module_by_xml(yspec, x, &ymod) < 0)
	    goto done;
	if (ymod == NULL)
	    continue;
	if ((yrpc = yang_find(ymod, Y_RPC, name)) == NULL)
	    continue;
	//	xml_spec_set(xrpc, yrpc);
	if ((yo = yang_find(yrpc, Y_OUTPUT, NULL)) == NULL)
	    continue;
	/* xml_spec_populate need to have parent with yang spec for
	 * recursive population to work. Therefore, assign input yang
	 * to rpc level although not 100% intuitive */
	break;
    }
    if (yo != NULL){
	xml_spec_set(xrpc, yo); 
	if ((ret = xml_spec_populate(xrpc, yspec, xerr)) < 0)
	    goto done;
	if (ret == 0)
	    goto fail;
    }
    retval = 1;
 done:
    return retval;
 fail:
    retval = 0;
    goto done;
}

/*! Associate XML node x with x:s parents yang:s matching child
 *
 * @param[in]   xt     XML tree node
 * @param[out]  xerr   Reason for failure, or NULL
 * @retval      2      OK yang assignment made
 * @retval      1      OK, Yang assignment not made because yang parent is anyxml or anydata
 * @retval      0      Yang assigment not made and xerr set
 * @retval     -1      Error
 * @see populate_self_top
 */
static int
populate_self_parent(cxobj  *xt,
		     cxobj **xerr)
{
    int        retval = -1;
    yang_stmt *y = NULL;     /* yang node */
    yang_stmt *yparent;      /* yang parent */
    cxobj     *xp = NULL;    /* xml parent */
    char      *name;
    char      *ns = NULL;    /* XML namespace of xt */
    char      *nsy = NULL;   /* Yang namespace of xt */

    xp = xml_parent(xt);
    name = xml_name(xt);
    if (xp == NULL){
	if (xerr &&
	    netconf_bad_element_xml(xerr, "application", name, "Missing parent") < 0)
	    goto done;
	goto fail;
    }
    if ((yparent = xml_spec(xp)) == NULL){
	if (xerr &&
	    netconf_bad_element_xml(xerr, "application", name, "Missing parent yang node") < 0)
	    goto done;
	goto fail;
    }
    if (yang_keyword_get(yparent) == Y_ANYXML || yang_keyword_get(yparent) == Y_ANYDATA){
	retval = 1;
	goto done;
    }
    if ((y = yang_find_datanode(yparent, name)) == NULL){
	if (xerr &&
	    netconf_bad_element_xml(xerr, "application", name, "Missing matching yang node") < 0)
	    goto done;
	goto fail;
    }
    if (xml2ns(xt, xml_prefix(xt), &ns) < 0)
	goto done;
    nsy = yang_find_mynamespace(y);
    if (ns == NULL || nsy == NULL){
	if (xerr &&
	    netconf_bad_element_xml(xerr, "application", name, "Missing namespace") < 0)
	    goto done;
	goto fail;
    }
    /* Assign spec only if namespaces match */
    if (strcmp(ns, nsy) != 0){
	if (xerr &&
	    netconf_bad_element_xml(xerr, "application", name, "Namespace mismatch") < 0)
	    goto done;
	goto fail;
    }
    xml_spec_set(xt, y);
    retval = 2;
 done:
    return retval;
 fail:
    retval = 0;
    goto done;
}

/*! Associate XML node x with yang spec y by going through all top-level modules and finding match
 *
 * @param[in]   xt     XML tree node
 * @param[in]   yspec  Yang spec
 * @param[out]  xerr   Reason for failure, or NULL
 * @retval      2      OK yang assignment made
 * @retval      1      OK, Yang assignment not made because yang parent is anyxml or anydata
 * @retval      0      yang assigment not made and xerr set
 * @retval     -1      Error
 * @see populate_self_parent
 */
static int
populate_self_top(cxobj     *xt, 
		  yang_stmt *yspec,
		  cxobj    **xerr)
{
    int        retval = -1;
    yang_stmt *y = NULL;     /* yang node */
    yang_stmt *ymod;         /* yang module */
    char      *name;
    char      *ns = NULL;    /* XML namespace of xt */
    char      *nsy = NULL;   /* Yang namespace of xt */

    name = xml_name(xt);
    if (yspec == NULL){
	if (xerr &&
	    netconf_bad_element_xml(xerr, "application", name, "Missing yang spec") < 0)
	    goto done;
	goto fail;
    }
    if (ys_module_by_xml(yspec, xt, &ymod) < 0)
	goto done;
    /* ymod is "real" module, name may belong to included submodule */
    if (ymod == NULL){
	if (xerr &&
	    netconf_bad_element_xml(xerr, "application", name, "No such yang module") < 0)
	    goto done;
	goto fail;
    }
    if ((y = yang_find_schemanode(ymod, name)) == NULL){ /* also rpc */
	if (xerr &&
	    netconf_bad_element_xml(xerr, "application", name, "Missing matching yang node") < 0)
	    goto done;
	goto fail;
    }
    if (xml2ns(xt, xml_prefix(xt), &ns) < 0)
	goto done;
    nsy = yang_find_mynamespace(y);
    if (ns == NULL || nsy == NULL){
	if (xerr &&
	    netconf_bad_element_xml(xerr, "application", name, "Missing namespace") < 0)
	    goto done;
	goto fail;
    }
    /* Assign spec only if namespaces match */
    if (strcmp(ns, nsy) != 0){
	if (xerr &&
	    netconf_bad_element_xml(xerr, "application", name, "Namespace mismatch") < 0)
	    goto done;
	goto fail;
    }
    xml_spec_set(xt, y);
    retval = 1;
 done:
    return retval;
 fail:
    retval = 0;
    goto done;
}

/*! Find yang spec association of XML node
 *
 * This may be unnecessary if yspec is set on manual creation. Also note that for incoming or outgoing RPC
 * need specialized function.
 * XXX: maybe it can be built into the same function, but you dont know whether it is input or output rpc, so
 * it seems like you need specialized functions.
 * @param[in]   xt     XML tree node
 * @param[in]   yspec  Yang spec
 * @param[out]  xerr   Reason for failure, or NULL
 * @retval      1      OK yang assignment made
 * @retval      0      Partial or no yang assigment made (at least one failed) and xerr set
 * @retval     -1      Error
 * @code
 *   if (xml_spec_populate(x, yspec, NULL) < 0)
 *     err;
 * @endcode
 * @note For subs to anyxml nodes will not have spec set
 * @see xml_spec_populate_rpc  for incoming rpc 
 */
int
xml_spec_populate(cxobj     *xt, 
		  yang_stmt *yspec,
		  cxobj    **xerr)
{
    int    retval = -1;
    cxobj *xc;         /* xml child */
    int    ret;
    int    failed = 0; /* we continue loop after failure, should we stop at fail?`*/

    xc = NULL;     /* Apply on children */
    while ((xc = xml_child_each(xt, xc, CX_ELMNT)) != NULL) {
	if ((ret = xml_spec_populate0(xc, yspec, xerr)) < 0)
	    goto done;
	if (ret == 0)
	    failed++;
    }
    retval = (failed==0) ? 1 : 0;
 done:
    return retval;
}

int
xml_spec_populate_parent(cxobj  *xt,
			 cxobj **xerr)
{
    int    retval = -1;
    cxobj *xc;           /* xml child */
    int    ret;
    int    failed = 0; /* we continue loop after failure, should we stop at fail?`*/
    
    xc = NULL;     /* Apply on children */
    while ((xc = xml_child_each(xt, xc, CX_ELMNT)) != NULL) {
	if ((ret = xml_spec_populate0_parent(xc, xerr)) < 0)
	    goto done;
	if (ret == 0)
	    failed++;
    }
    retval = (failed==0) ? 1 : 0;
 done:
    return retval;
}

int
xml_spec_populate0(cxobj     *xt, 
		   yang_stmt *yspec,
		   cxobj    **xerr)
{
    int    retval = -1;
    cxobj *xc;           /* xml child */
    int    ret;
    int    failed = 0; /* we continue loop after failure, should we stop at fail?`*/

    if ((ret = populate_self_top(xt, yspec, xerr)) < 0) 
	goto done;
    if (ret == 1){
	xc = NULL;     /* Apply on children */
	while ((xc = xml_child_each(xt, xc, CX_ELMNT)) != NULL) {
	    if ((ret = xml_spec_populate0_parent(xc, xerr)) < 0)
		goto done;
	    if (ret == 0)
		failed++;
	}
    }
    retval = (failed==0) ? 1 : 0;
 done:
    return retval;
}

int
xml_spec_populate0_parent(cxobj  *xt,
			  cxobj **xerr)
{
    int    retval = -1;
    cxobj *xc;           /* xml child */
    int    ret;
    int    failed = 0; /* we continue loop after failure, should we stop at fail?`*/
    
    if ((ret = populate_self_parent(xt, xerr)) < 0)
	goto done;
    if (ret == 0)
	failed++;
    else if (ret != 1){ /* 1 means anyxml parent */
	xc = NULL;     /* Apply on children */
	while ((xc = xml_child_each(xt, xc, CX_ELMNT)) != NULL) {
	    if ((ret = xml_spec_populate0_parent(xc, xerr)) < 0)
		goto done;
	    if (ret == 0)
		failed++;
	}
    }
    retval = (failed==0) ? 1 : 0;
 done:
    return retval;
}

/*! Given an XML node, build an xpath to root, internal function
 * @retval     0      OK
 * @retval    -1      Error. eg XML malformed
 */
static int
xml2xpath1(cxobj *x,
	   cbuf  *cb)
{
    int           retval = -1;
    cxobj        *xp;
    yang_stmt    *y = NULL;
    cvec         *cvk = NULL; /* vector of index keys */
    cg_var       *cvi;
    char         *keyname;
    cxobj        *xkey;
    cxobj        *xb;
    char         *b;
    enum rfc_6020 keyword;
    
    if ((xp = xml_parent(x)) != NULL &&
	xml_spec(xp) != NULL)
	xml2xpath1(xp, cb);
    /* XXX: sometimes there should be a /, sometimes not */
    cprintf(cb, "/%s", xml_name(x));
    if ((y = xml_spec(x)) != NULL){
	keyword = yang_keyword_get(y);
	switch (keyword){
	case Y_LEAF_LIST:
	    if ((b = xml_body(x)) != NULL)
		cprintf(cb, "[.=\"%s\"]", b);
	    else
		cprintf(cb, "[.=\"\"]");
	    break;
	case Y_LIST:
	    cvk = yang_cvec_get(y);
	    cvi = NULL;
	    while ((cvi = cvec_each(cvk, cvi)) != NULL) {
		keyname = cv_string_get(cvi);
		if ((xkey = xml_find(x, keyname)) == NULL)
		    goto done; /* No key in xml */
		if ((xb = xml_find(x, keyname)) == NULL)
		    goto done;
		b = xml_body(xb);
		cprintf(cb, "[%s=\"%s\"]", keyname, b?b:"");
	    }
	    break;
	default:
	    break;
	}
    }
    retval = 0;
 done:
    return retval;
}

/*! Given an XML node, build an xpath to root
 * Builds only unqualified xpaths, ie no predicates []
 * @param[in]  x      XML object
 * @param[out] xpath  Malloced xpath string. Need to free() after use
 * @retval     0      OK
 * @retval    -1      Error. (eg XML malformed)
 */
int
xml2xpath(cxobj *x,
	  char **xpathp)
{
    int   retval = -1;
    cbuf *cb;
    char *xpath = NULL;

    if ((cb = cbuf_new()) == NULL){
	clicon_err(OE_XML, errno, "cbuf_new");
	goto done;
    }
    if (xml2xpath1(x, cb) < 0)
	goto done;
    /* XXX: see xpath in test statement,.. */
    xpath = cbuf_get(cb);
    if (xpathp){
	if ((*xpathp = strdup(xpath)) == NULL){
	    clicon_err(OE_UNIX, errno, "strdup");
	    goto done;
	}
	xpath = NULL;
    }
    retval = 0;
 done:
    if (cb)
	cbuf_free(cb);
    return retval;
}


/*! Check if the module tree x is in is assigned right XML namespace, assign if not
 * @param[in]  x   XML node
 *(0. You should probably find the XML root and apply this function to that.)
 * 1. Check which namespace x should have (via yang). This is correct namespace.
 * 2. Check which namespace x has via its XML tree
 * 3. If equal, OK
 * 4. Assign the correct namespace to the XML node
 * Assign default namespace to x. Create an "xmlns"
 * @code
 *    xml_yang_root(x, &xroot);
 *    xmlns_assign(xroot);
 * @endcode
 */
int
xmlns_assign(cxobj *x)
{
    int        retval = -1;
    yang_stmt *y;
    char      *ns_correct; /* correct uri */
    char      *ns_xml;     /* may be null or incorrect */

    if ((y = xml_spec(x)) == NULL){
	clicon_err(OE_YANG, ENOENT, "XML %s does not have yang spec", xml_name(x));
	goto done;
    }
    /* 1. Check which namespace x should have (via yang). This is correct namespace. */
    if ((ns_correct = yang_find_mynamespace(y)) == NULL){
	clicon_err(OE_YANG, ENOENT, "yang node %s does not have namespace", yang_argument_get(y));
	goto done;
    }
    /* 2. Check which namespace x has via its XML tree */
    if (xml2ns(x, NULL, &ns_xml) < 0)
	goto done;
    /* 3. If equal, OK, 4. Else, find root of XML tree */
    if (ns_xml && strcmp(ns_xml, ns_correct)==0)
	goto ok;
    /* 4. Assign the correct namespace */
    if (xmlns_set(x, NULL, ns_correct) < 0)
	goto done;
 ok:
    retval = 0;
 done:
    return retval;
}

/*! Given a src node x0 and a target node x1, assign (optional) prefix and namespace
 * @param[in]  x0       Source XML tree
 * @param[in]  x1       Target XML tree
 * 1. Find N=namespace(x0)
 * 2. Detect if N is declared in x1 parent
 * 3. If yes, assign prefix to x1
 * 4. If no, create new prefix/namespace binding and assign that to x1p (x1 if x1p is root)
 * 5. Add prefix to x1, if any
 * 6. Ensure x1 cache is updated
 * @note switch use of x0 and x1 compared to datastore text_modify
 * @see xml2ns
 * XXX: fail handling: 		if (netconf_data_missing(cbret, NULL, "Data does not exist; cannot delete resource") < 0)
		    goto done;
 */
int
assign_namespaces(cxobj *x0, /* source */
		  cxobj *x1, /* target */
		  cxobj *x1p)
{
    int        retval = -1;
    char      *namespace = NULL;
    char      *prefix0 = NULL;;
    char      *prefix1 = NULL;
    char      *prefixb = NULL; /* identityref body prefix */
    cvec      *nsc0 = NULL;
    cvec      *nsc = NULL;
    int        isroot;
    char      *pexist = NULL;
    yang_stmt *y;
    
    /* XXX: need to identify root better than hiereustics and strcmp,... */
    isroot = xml_parent(x1p)==NULL &&
	(strcmp(xml_name(x1p), "config") == 0 || strcmp(xml_name(x1p), "top") == 0)&&
	xml_prefix(x1p)==NULL;

    /* 1. Find N=namespace(x0) */
    prefix0 = xml_prefix(x0);
    if (xml2ns(x0, prefix0, &namespace) < 0)
	goto done;
    if (namespace == NULL){
	clicon_err(OE_XML, ENOENT, "No namespace found for prefix:%s",
		   prefix0?prefix0:"NULL");
	goto done;
    }
    /* 2a. Detect if namespace is declared in x1 target parent */
    if (xml2prefix(x1p, namespace, &pexist) == 1){
	/* Yes, and it has prefix pexist */
	if (pexist){
	    if ((prefix1 = strdup(pexist)) == NULL){
		clicon_err(OE_UNIX, errno, "strdup");
		goto done;
	    }
	}
	else
	    prefix1 = NULL;
	/* 3. If yes, assign prefix to x1 */
	if (prefix1 && xml_prefix_set(x1, prefix1) < 0)
	    goto done;
	/* And copy namespace context from parent to child */
	if ((nsc0 = nscache_get_all(x1p)) != NULL){
	    if ((nsc = cvec_dup(nsc0)) == NULL){
		clicon_err(OE_UNIX, errno, "cvec_dup");
		goto done;
	    }
	    nscache_replace(x1, nsc);
	}
	/* Just in case */
	if (nscache_set(x1, prefix1, namespace) < 0)
	    goto done;
    }
    else{ /* No, namespace does not exist in x1 _parent_ 
	   * Check if it is exists in x1 itself */
	if (xml2prefix(x1, namespace, &pexist) == 1){
	    /* Yes it exists, but is it equal? */
	    if (clicon_strcmp(pexist, prefix0) == 0)
		    ; /* Equal, reuse */
	    else{ /* namespace exist, but not equal, use existing */
		/* Add prefix to x1, if any */
		if (pexist && xml_prefix_set(x1, pexist) < 0)
		    goto done;
	    }
	    goto ok; /* skip */
	}
	else { /* namespace does not exist in target x1, use source prefix 
		* use the prefix defined in the module
		*/
	    if (isroot){
		if (prefix0 && (prefix1 = strdup(prefix0)) == NULL){
		    clicon_err(OE_UNIX, errno, "strdup");
		    goto done;
		}
	    }
	    else{
		y = xml_spec(x0);
		if ((prefix1 = strdup(yang_find_myprefix(y))) == NULL){
		    clicon_err(OE_UNIX, errno, "strdup");
		    goto done;
		}
	    }
	}
	if (add_namespace(x1, prefix1, namespace) < 0)
	    goto done;
    }
 ok:
    /* 6. Ensure x1 cache is updated (I think it is done w xmlns_set above) */
    retval = 0;
 done:
    if (prefixb)
	free(prefixb);
    if (prefix1)
	free(prefix1);
    return retval;
}

/*! Merge a base tree x0 with x1 with yang spec y
 * @param[in]  x0  Base xml tree (can be NULL in add scenarios)
 * @param[in]  y0  Yang spec corresponding to xml-node x0. NULL if x0 is NULL
 * @param[in]  x0p Parent of x0
 * @param[in]  x1  xml tree which modifies base
 * @param[out] reason If retval=0 a malloced string
 * @retval     0     OK. If reason is set, Yang error
 * @retval    -1     Error
 * Assume x0 and x1 are same on entry and that y is the spec
 */
static int
xml_merge1(cxobj              *x0,  /* the target */
	   yang_stmt          *y0,
	   cxobj              *x0p,
	   cxobj              *x1,  /* the source */
	   char              **reason)
{
    int        retval = -1;
    char      *x1cname; /* child name */
    cxobj     *x0c; /* base child */
    cxobj     *x0b; /* base body */
    cxobj     *x1c; /* mod child */
    char      *x1name;
    char      *x1bstr; /* mod body string */
    yang_stmt *yc;  /* yang child */
    cbuf      *cbr = NULL; /* Reason buffer */

    assert(x1 && xml_type(x1) == CX_ELMNT);
    assert(y0);

    x1name = xml_name(x1);
    if (yang_keyword_get(y0) == Y_LEAF_LIST || yang_keyword_get(y0) == Y_LEAF){
	x1bstr = xml_body(x1);
	if (x0==NULL){
	    if ((x0 = xml_new(x1name, x0p, (yang_stmt*)y0)) == NULL)
		goto done;
	    if (x1bstr){ /* empty type does not have body */
		if ((x0b = xml_new("body", x0, NULL)) == NULL)
		    goto done; 
		xml_type_set(x0b, CX_BODY);
	    }
	}
	if (x1bstr){
	    if ((x0b = xml_body_get(x0)) == NULL){
		if ((x0b = xml_new("body", x0, NULL)) == NULL)
		    goto done; 
		xml_type_set(x0b, CX_BODY);
	    }
	    if (xml_value_set(x0b, x1bstr) < 0)
		goto done;
	}
	if (assign_namespaces(x1, x0, x0p) < 0)
	    goto done;
    } /* if LEAF|LEAF_LIST */
    else { /* eg Y_CONTAINER, Y_LIST  */
	if (x0==NULL){
	    if ((x0 = xml_new(x1name, NULL, (yang_stmt*)y0)) == NULL)
		goto done;
	}
	if (assign_namespaces(x1, x0, x0p) < 0)
	    goto done;
	/* Loop through children of the modification tree */
	x1c = NULL;
	while ((x1c = xml_child_each(x1, x1c, CX_ELMNT)) != NULL) {
	    x1cname = xml_name(x1c);
	    /* Get yang spec of the child */
	    if ((yc = yang_find_datanode(y0, x1cname)) == NULL){
		if (reason){
		    if ((cbr = cbuf_new()) == NULL){
			clicon_err(OE_XML, errno, "cbuf_new");
			goto done;
		    }
		    cprintf(cbr, "XML node %s/%s has no corresponding yang specification (Invalid XML or wrong Yang spec?", xml_name(x1), x1cname);
		    if ((*reason = strdup(cbuf_get(cbr))) == NULL){
			clicon_err(OE_UNIX, errno, "strdup");
			goto done;
		    }
		}
		break;
	    }
	    /* See if there is a corresponding node in the base tree */
	    x0c = NULL;
	    if (yc && match_base_child(x0, x1c, yc, &x0c) < 0)
		goto done;
	    if (xml_merge1(x0c, yc, x0, x1c, reason) < 0)
		goto done;
	    if (*reason != NULL)
		goto ok;
	} /* while */
	if (xml_parent(x0) == NULL &&
	    xml_insert(x0p, x0, INS_LAST, NULL, NULL) < 0) 
	    goto done;
    } /* else Y_CONTAINER  */
 ok:
    retval = 0;
 done:
    if (cbr)
	cbuf_free(cbr);
    return retval;
}

/*! Merge XML trees x1 into x0 according to yang spec yspec
 * @param[in]  x0    Base xml tree (can be NULL in add scenarios)
 * @param[in]  x1    xml tree which modifies base
 * @param[in]  yspec Yang spec
 * @param[out] reason If retval=0, reason is set. Malloced. Needs to be freed by caller
 * @retval     0     OK. If reason is set, Yang error
 * @retval    -1     Error
 * @note both x0 and x1 need to be top-level trees
 * @see text_modify_top as more generic variant (in datastore text)
 * @note returns -1 if YANG do not match, you may want to have a softer error
 */
int
xml_merge(cxobj     *x0,
	  cxobj     *x1,
	  yang_stmt *yspec,
	  char     **reason)
{
    int        retval = -1;
    char      *x1cname; /* child name */
    cxobj     *x0c; /* base child */
    cxobj     *x1c; /* mod child */
    yang_stmt *yc;
    yang_stmt *ymod;
    cbuf      *cbr = NULL; /* Reason buffer */

    if (x0 == NULL || x1 == NULL){
	clicon_err(OE_UNIX, EINVAL, "parameters x0 or x1 is NULL");
	goto done;
	goto done;
    }
    /* Loop through children of the modification tree */
    x1c = NULL;
    while ((x1c = xml_child_each(x1, x1c, CX_ELMNT)) != NULL) {
	x1cname = xml_name(x1c);
	if ((ys_module_by_xml(yspec, x1c, &ymod)) < 0)
	    goto done;
	if (ymod == NULL){
	    if (reason &&
		(*reason = strdup("Namespace not found or yang spec not loaded")) == NULL){
		    clicon_err(OE_UNIX, errno, "strdup");
		    goto done;
	    }
	    goto ok;	
	}
	/* Get yang spec of the child */
	if ((yc = yang_find_datanode(ymod, x1cname)) == NULL){
	    if (reason){
		if ((cbr = cbuf_new()) == NULL){
		    clicon_err(OE_XML, errno, "cbuf_new");
		    goto done;
		}
		cprintf(cbr, "XML node %s/%s has no corresponding yang specification (Invalid XML or wrong Yang spec?)", xml_name(x1), x1cname);
		if ((*reason = strdup(cbuf_get(cbr))) == NULL){
		    clicon_err(OE_UNIX, errno, "strdup");
		    goto done;
		}
	    }
	    break;
	}
	/* See if there is a corresponding node in the base tree */
	if (match_base_child(x0, x1c, yc, &x0c) < 0)
	    goto done;
	/* There is a case where x0c and x1c are choice nodes, if so,
	 * it is treated as a match, and x0c will remain 
	 * If it is overwritten, then x0c should be removed here.
	 */
	if (xml_merge1(x0c, yc, x0, x1c, reason) < 0)
	    goto done;
	if (*reason != NULL)
	    break;
    }
 ok:
    retval = 0; /* OK */
 done:
    if (cbr)
	cbuf_free(cbr);
    return retval;
}

/*! Get integer value from xml node from yang enumeration 
 * @param[in]  node XML node in a tree
 * @param[out] val  Integer value returned
 * @retval     0    OK, value parsed
 * @retval    -1    Error, value not obtained or parsed, no reason given
 * @note assume yang spec set
 * @note The function only returns assigned values, but according to RFC:
   If a value is not specified, then one will be automatically assigned.
   If the "enum" substatement is the first one defined, the assigned
   value is zero (0); otherwise, the assigned value is one greater than
   the current highest enum value (i.e., the highest enum value,
   * Thanks: Matthew Smith
 */
int
yang_enum_int_value(cxobj   *node, 
		    int32_t *val)
{
    int retval = -1;
    yang_stmt *yspec;
    yang_stmt *ys;
    yang_stmt *ytype;
    yang_stmt *yrestype;  /* resolved type */
    yang_stmt *yenum; 
    yang_stmt *yval; 
    char      *reason = NULL;

    if (node == NULL)
	goto done;
    if ((ys = (yang_stmt *) xml_spec(node)) == NULL)
	goto done;
    if ((yspec = ys_spec(ys)) == NULL)
	goto done;
    if ((ytype = yang_find(ys, Y_TYPE, NULL)) == NULL)
	goto done;
    if (yang_type_resolve(ys, ys, ytype, &yrestype, 
			  NULL, NULL, NULL, NULL, NULL) < 0)
	goto done;
    if (yrestype==NULL || strcmp(yang_argument_get(yrestype), "enumeration"))
	goto done;
    if ((yenum = yang_find(yrestype, Y_ENUM, xml_body(node))) == NULL)
	goto done;
    /* Should assign value if yval not found */
    if ((yval = yang_find(yenum, Y_VALUE, NULL)) == NULL)
	goto done;
    /* reason is string containing why int could not be parsed */
    if (parse_int32(yang_argument_get(yval), val, &reason) < 0)
	goto done;
    retval = 0;
done:
    return retval;
}




