/*
 *
  ***** BEGIN LICENSE BLOCK *****
 
  Copyright (C) 2009-2016 Olof Hagsand and Benny Holmgren
  Copyright (C) 2017-2019 Olof Hagsand
  Copyright (C) 2020 Olof Hagsand and Rubicon Communications, LLC

  This file is part of CLIXON.

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.

  Alternatively, the contents of this file may be used under the terms of
  the GNU General Public License Version 3 or later (the "GPL"),
  in which case the provisions of the GPL are applicable instead
  of those above. If you wish to allow use of your version of this file only
  under the terms of the GPL, and not to allow others to
  use your version of this file under the terms of Apache License version 2, 
  indicate your decision by deleting the provisions above and replace them with
  the  notice and other provisions required by the GPL. If you do not delete
  the provisions above, a recipient may use your version of this file under
  the terms of any one of the Apache License version 2 or the GPL.

  ***** END LICENSE BLOCK *****

 * Clixon XML object (cxobj) support functions.
 * @see https://www.w3.org/TR/2008/REC-xml-20081126
 *      https://www.w3.org/TR/2009/REC-xml-names-20091208
 * Canonical XML version (just for info)
 *      https://www.w3.org/TR/xml-c14n
 */

#ifdef HAVE_CONFIG_H
#include "clixon_config.h" /* generated by config & autoconf */
#endif

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <inttypes.h>
#include <unistd.h>
#include <errno.h>
#include <string.h>
#include <limits.h>
#include <assert.h>

/* cligen */
#include <cligen/cligen.h>

/* clixon */
#include "clixon_err.h"
#include "clixon_string.h"
#include "clixon_queue.h"
#include "clixon_hash.h"
#include "clixon_handle.h"
#include "clixon_log.h"
#include "clixon_yang.h"
#include "clixon_xml.h"
#include "clixon_options.h" /* xml_spec_populate */
#include "clixon_yang_module.h"
#include "clixon_xml_map.h" /* xml_spec_populate */
#include "clixon_xml_vec.h"
#include "clixon_xml_sort.h"
#include "clixon_xml_parse.h"
#include "clixon_xml_nsctx.h"

/*
 * Constants
 */
/* Size of xml read buffer */
#define BUFLEN 1024  
/* Indentation for xml pretty-print. Consider option? */
#define XML_INDENT 3 
/* Name of xml top object created by xml parse functions */
#define XML_TOP_SYMBOL "top" 
/* How many XML children to start with if any (and then add exponentialy) */
#define XML_CHILDVEC_MAX_DEFAULT 4
/* Initial length of x_value malloced string */
#define XML_VALUE_MAX_DEFAULT 32

/*
 * Types
 */

#ifdef XML_EXPLICIT_INDEX
static int xml_search_index_free(cxobj *x);

/* A search index pair consisting of a name of an (index) variable and a vector of xml children
 * the variable should be a potential child of the XML node
 * The vector should have the same elements as the regular XML childvec, but in different order
 *
 *                        +-----+-----+-----+
 * search index vector i: |  b  |  c  |  a  |
 *                        +-----+-----+-----+
 *
 *                    index: "i"
 *               +-----+-----+-----+
 * x_childvec:   |  a  |  b  |  c  |
 *               +-----+-----+-----+
 *                  |     |     |
 *                  v     v     v
 *                +---+ +---+ +---+
 * value of "i"   | 5 | | 0 | | 2 |
 *                +---+ +---+ +---+

 */
struct search_index{
    qelem_t      si_q;    /* Queue header */
    char        *si_name; /* Name of index variable (must be (potential) child of xml node at hand */
    clixon_xvec *si_xvec; /* Sorted vector of xml object pointers (should be of YANG type LIST) */
};
#endif

/*! xml tree node, with name, type, parent, children, etc 
 * Note that this is a private type not visible from externally, use
 * access functions.
 * A word on ordering of x_children:
 * If there is no yang specification, xml children are ordered as they are entered.
 * If there is a yang specification (and the appropriate functions are called) the
 * xml children are ordered as follows:
 * 1) After yang specification order.
 * 2) list and leaf-list are sorted alphabetically unless ordered-by user.
 * Example:
 * container c{
 *  leaf a;
 *  leaf-list x;
 * }
 * then regardless in which order the xml is entered, it will be sorted as follows:
 * <c>
 *   <a/>
 *   <x>a</<x>
 *   <x>b</<x>
 * </c>
 * From https://www.w3.org/TR/2009/REC-xml-names-20091208
 * Definitions:
 * - XML namespace: is identified by a URI reference [RFC3986]; element and 
 *   attribute names may be placed in an XML namespace using the mechanisms 
 *   described in this specification.
 * - Expanded name: is a pair consisting of a namespace name and a local name.
 * - Namespace name: For a name N in a namespace identified by a URI I, the 
 *   "namespace name" is I.
 *   For a name N that is not in a namespace, the "namespace name" has no value.
 * - Local name: In either case the "local name" is N (also "prefix")
 * It is this combination of the universally managed URI namespace with the 
 * vocabulary's local names that is effective in avoiding name clashes.
 */
struct xml{
    char             *x_name;       /* name of node */
    char             *x_prefix;     /* namespace localname N, called prefix */
    struct xml       *x_up;         /* parent node in hierarchy if any */
    struct xml      **x_childvec;   /* vector of children nodes (XXX: use clixon_vec ) */
    int               x_childvec_len;/* Number of children */
    int               x_childvec_max;/* Length of allocated vector */
    enum cxobj_type   x_type;       /* type of node: element, attribute, body */
    cbuf             *x_value_cb;   /* attribute and body nodes have values (XXX: this consumes 
				       memory) cv? */
    int               x_flags;      /* Flags according to XML_FLAG_* */
    yang_stmt        *x_spec;       /* Pointer to specification, eg yang, by 
				       reference, dont free */
    cg_var           *x_cv;         /* Cached value as cligen variable (eg xml_cmp) */
    cvec             *x_ns_cache;   /* Cached vector of namespaces */
    int              _x_vector_i;   /* internal use: xml_child_each */
    int              _x_i;          /* internal use for sorting: 
				       see xml_enumerate and xml_cmp */
#ifdef XML_EXPLICIT_INDEX
    struct search_index *x_search_index; /* explicit search index vectors */
#endif
};

/*
 * Variables
 */

/* Mapping between xml type <--> string */
static const map_str2int xsmap[] = {
    {"error",         CX_ERROR}, 
    {"element",       CX_ELMNT}, 
    {"attr",          CX_ATTR}, 
    {"body",          CX_BODY},
    {NULL,           -1}
};

/*! Translate from xml type in enum form to string keyword
 * @param[in] type  Xml type
 * @retval    str   String keyword
 */
char *
xml_type2str(enum cxobj_type type)
{
    return (char*)clicon_int2str(xsmap, type);
}

/* Stats */
uint64_t _stats_nr = 0;

/*! Get global statistics about XML objects
 */
int
xml_stats_global(uint64_t *nr)
{
    if (nr)
	*nr = _stats_nr;
    return 0;
}

/*! Return the alloced memory of a single XML obj 
 * @param[in]   x    XML object
 * @param[out]  szp  Size of this XML obj
 * @retval      0    OK
 * (baseline: 96 bytes per object on x86-64)
 */
static int
xml_stats_one(cxobj    *x,
	      size_t   *szp)
{
    size_t sz = 0;

    sz += sizeof(struct xml);
    if (x->x_name)
	sz += strlen(x->x_name) + 1;
    if (x->x_prefix)
	sz += strlen(x->x_prefix) + 1;
    sz += x->x_childvec_max*sizeof(struct xml*);
    if (x->x_value_cb)
	sz += cbuf_buflen(x->x_value_cb);
    if (x->x_cv)
	sz += cv_size(x->x_cv);
    if (x->x_ns_cache)
	sz += cvec_size(x->x_ns_cache);
    if (szp)
	*szp = sz;
    return 0;
}

/*! Return statistics of an XML tree recursively
 * @param[in]   x    XML object
 * @param[out]  szp  Size of this XML obj recursively
 * @retval      0    OK
 */
size_t
xml_stats(cxobj    *xt,
	  uint64_t *nrp,
	  size_t   *szp)
{
    size_t sz = 0;
    cxobj *xc;

    *nrp += 1;
    xml_stats_one(xt, &sz);
    if (szp)
	*szp += sz;
    xc = NULL;
    while ((xc = xml_child_each(xt, xc, -1)) != NULL) {
	xml_stats(xc, nrp, &sz);
	if (szp)
	    *szp += sz;
    }
    return 0;
}

/*
 * Access functions
 */
/*! Get name of xnode
 * @param[in]  xn    xml node
 * @retval     name of xml node
 */
char*
xml_name(cxobj *xn)
{
    return xn->x_name;
}

/*! Set name of xnode, name is copied
 * @param[in]  xn    xml node
 * @param[in]  name  new name, null-terminated string, copied by function
 * @retval     -1    on error with clicon-err set
 * @retval     0     OK
 */
int
xml_name_set(cxobj *xn, 
	     char  *name)
{
    if (xn->x_name){
	free(xn->x_name);
	xn->x_name = NULL;
    }
    if (name){
	if ((xn->x_name = strdup(name)) == NULL){
	    clicon_err(OE_XML, errno, "strdup");
	    return -1;
	}
    }
    return 0;
}

/*! Get prefix of xnode
 * @param[in]  xn     xml node
 * @retval     prefix of xml node
 */
char*
xml_prefix(cxobj *xn)
{
    return xn->x_prefix;
}

/*! Set prefix of xnode, prefix is copied
 * @param[in]  xn         xml node
 * @param[in]  localname  new prefix, null-terminated string, copied by function
 * @retval     -1         on error with clicon-err set
 * @retval     0          OK
 */
int
xml_prefix_set(cxobj *xn, 
	       char  *localname)
{
    if (xn->x_prefix){
	free(xn->x_prefix);
	xn->x_prefix = NULL;
    }
    if (localname){
	if ((xn->x_prefix = strdup(localname)) == NULL){
	    clicon_err(OE_XML, errno, "strdup");
	    return -1;
	}
    }
    return 0;
}

/*! Get cached namespace (given prefix)
 * @param[in] x      XML node
 * @param[in] prefix Namespace prefix, or NULL for default
 * @retval    ns     Cached namespace
 * @retval    NULL   No namespace found (not cached or not found)
 * @note may want to distinguish between not set cache and no namespace?
 */
char*
nscache_get(cxobj *x,
	    char  *prefix)
{
    if (x->x_ns_cache != NULL)
	return xml_nsctx_get(x->x_ns_cache, prefix);
    return NULL;
}

/*! Get cached prefix (given namespace) 
 * @param[in]  x         XML node
 * @param[in]  namespace
 * @param[out] prefix
 * @retval     0      No prefix found
 * @retval     1      Prefix found
 */
int
nscache_get_prefix(cxobj *x,
		   char  *namespace,
		   char **prefix)
{
    if (x->x_ns_cache != NULL)
	return xml_nsctx_get_prefix(x->x_ns_cache, namespace, prefix);
    return 0;
}

/*! Dump whole namespace context cache of one xml node 
 * @param[in]  x    XML node
 * @retval     nsc  Whole namespace context of x
 * @retval     NULL Empty nsc
 * @see nscache_get  For a single prefix
 */
cvec *
nscache_get_all(cxobj *x)
{
    return x->x_ns_cache;
}

/*! Set cached namespace for specific namespace. Replace if necessary
 * @param[in] x         XML node
 * @param[in] prefix    Namespace prefix, or NULL for default
 * @param[in] namespace Cached namespace to set (assume non-null?)
 * @retval    0         OK
 * @retval   -1         Error
 * @see nscache_replace  to replace the whole context
 */
int
nscache_set(cxobj *x,
	    char  *prefix,
	    char  *namespace)
{
    int     retval = -1;

    if (x->x_ns_cache == NULL){
	if ((x->x_ns_cache = xml_nsctx_init(prefix, namespace)) == NULL)
	    goto done;
    }
    else 
	return xml_nsctx_add(x->x_ns_cache, prefix, namespace);
    retval = 0;
 done:
    return retval;
}

/*! Set complete cached namespace context
 * @param[in] x      XML node
 * @param[in] nsc    Namespace context (note consumed, dont free)
 * @retval    0      OK
 * @retval   -1      Error
 * @see nscache_set  set a single cache line
 */
int
nscache_replace(cxobj *x,
		cvec  *nsc)
{
    int     retval = -1;

    if (x->x_ns_cache != NULL){
	xml_nsctx_free(x->x_ns_cache);
	x->x_ns_cache = NULL;
    }
    x->x_ns_cache = nsc;
    retval = 0;
    // done:
    return retval;
}

/*! Clear cached namespace context
 * Clear the whole namespace context, not just single cache lines
 * @param[in] x         XML node
 * @retval    0         OK
 * @see nscache_set  For setting specific namespace cache lines
 * @see xml_addsub
 */
int
nscache_clear(cxobj *x)
{
    if (x->x_ns_cache != NULL){
	xml_nsctx_free(x->x_ns_cache);
	x->x_ns_cache = NULL;
    }
    return 0;
}

/*! Given an xml tree return URI namespace recursively : default or localname given
 *
 * Given an XML tree and a prefix (or NULL) return URI namespace.
 * @param[in]  x          XML tree
 * @param[in]  prefix     prefix/ns localname. If NULL then return default.
 * @param[out] namespace  URI namespace (or NULL). Note pointer into xml tree
 * @retval     0          OK
 * @retval    -1          Error
 * @code
 *   if (xml2ns(xt, NULL, &namespace) < 0)
 *      err;
 * @endcode
 * @see xmlns_check 
 * @see xmlns_set cache is set
 * @note, this function uses a cache. 
 */
int
xml2ns(cxobj *x,
       char  *prefix,
       char **namespace)
{
    int    retval = -1;
    char  *ns = NULL;
    cxobj *xp;
    
    if ((ns = nscache_get(x, prefix)) != NULL)
	goto ok;
    if (prefix != NULL) /* xmlns:<prefix>="<uri>" */
	ns = xml_find_type_value(x, "xmlns", prefix, CX_ATTR);
    else{                /* xmlns="<uri>" */
    	ns = xml_find_type_value(x, NULL, "xmlns", CX_ATTR);
    }
    /* namespace not found, try parent */
    if (ns == NULL){
	if ((xp = xml_parent(x)) != NULL){
	    if (xml2ns(xp, prefix, &ns) < 0)
		goto done;
	}
	/* If no parent, return default namespace if defined */
#ifdef USE_NETCONF_NS_AS_DEFAULT
	else{
	    if (prefix == NULL)
		ns = NETCONF_BASE_NAMESPACE;
	    else
		ns = NULL;
	}
#endif
    }
    /* Set default namespace cache (since code is at this point,
     * no cache was found */
    if (ns && nscache_set(x, prefix, ns) < 0)
	goto done;
 ok:
    if (namespace)
	*namespace = ns;
    retval = 0;
 done:
    return retval;
}

/*! Add a namespace attribute to an XML node, either default or specific prefix
 * @param[in]  x          XML tree
 * @param[in]  prefix     prefix/ns localname. If NULL then set default xmlns
 * @param[in]  ns         URI namespace (or NULL). Will be copied
 * @retval     0          OK
 * @retval    -1          Error
 * @see xml2ns 
 */
int
xmlns_set(cxobj *x,
	  char  *prefix,
	  char  *ns)
{
    int    retval = -1;
    cxobj *xa;

    if (prefix != NULL){ /* xmlns:<prefix>="<uri>" */
	if ((xa = xml_new(prefix, x, NULL)) == NULL)
	    goto done;
	if (xml_prefix_set(xa, "xmlns") < 0)
	    goto done;
    }
    else{                /* xmlns="<uri>" */
	if ((xa = xml_new("xmlns", x, NULL)) == NULL)
	    goto done;
    }
    xml_type_set(xa, CX_ATTR);
    if (xml_value_set(xa, ns) < 0)
	goto done;
    /* (re)set namespace cache (as used in xml2ns) */
    if (ns && nscache_set(x, prefix, ns) < 0)
	goto done;
    retval = 0;
 done:
    return retval;
}

/*! Get namespace given prefix recursively 
 * @param[in]  xn        XML node
 * @param[in]  namespace Namespace
 * @param[out] prefixp   Pointer to prefix if found
 * @retval    -1         Error
 * @retval     0         No namespace found
 * @retval     1         Namespace found, prefix returned in prefixp
 */
int
xml2prefix(cxobj *xn,
	   char  *namespace,
	   char **prefixp)
{
    int    retval = -1;
    cxobj *xa = NULL;
    cxobj *xp;
    char  *prefix = NULL;
    char  *xaprefix;
    int    ret;

    if (nscache_get_prefix(xn, namespace, &prefix) == 1) /* found */
	goto found;
    xa = NULL;
    while ((xa = xml_child_each(xn, xa, CX_ATTR)) != NULL) {
	/* xmlns=namespace */
	if (strcmp("xmlns", xml_name(xa)) == 0){ 
	    if (strcmp(xml_value(xa), namespace) == 0){
		if (nscache_set(xn, NULL, namespace) < 0)
		    goto done;
		prefix = NULL; /* Maybe should set all caches in ns:s children? */
		goto found;
	    }
	}
	/* xmlns:prefix=namespace */
	else if ((xaprefix=xml_prefix(xa)) != NULL &&
		 strcmp("xmlns", xaprefix) == 0){ 
	    if (strcmp(xml_value(xa), namespace) == 0){
		prefix = xml_name(xa);
		if (nscache_set(xn, prefix, namespace) < 0)
		    goto done;
		goto found;
	    }
	}
    }
    if ((xp = xml_parent(xn)) != NULL){
	if ((ret = xml2prefix(xp, namespace, &prefix)) < 0)
	    goto done;
	if (ret == 1){
	    if (nscache_set(xn, prefix, namespace) < 0)
		goto done;
	    goto found;
	}
    }
    retval = 0;
 done:
    return retval;
 found:
    *prefixp = prefix;
    retval = 1;
    goto done;
}

/*! See if xmlns:[<localname>=]<uri> exists, if so return <uri>
 *
 * @param[in]  xn   XML node
 * @param[in]  nsn  Namespace name
 * @retval     URI  return associated URI if found
 * @retval     NULL No namespace name binding found for nsn
 * @see xml2ns XXX coordinate
 */
static char *
xmlns_check(cxobj *xn,
	    char  *nsn)
{
    cxobj *x = NULL;
    char  *xns;
    
    while ((x = xml_child_each(xn, x, CX_ATTR)) != NULL) 
	if ((xns = xml_prefix(x)) && strcmp(xns, "xmlns")==0 &&
	    strcmp(xml_name(x), nsn) == 0)
	    return xml_value(x);
    return NULL;
}

/*! Check namespace of xml node by searching recursively among ancestors 
 * @param[in]  xn         xml node
 * @param[in]  namespace  check validity of namespace
 * @retval     0          Found / validated or no yang spec
 * @retval    -1          Not found
 * @note This function is grossly inefficient
 */
static int
xml_localname_check(cxobj *xn, 
		    void  *arg)
{
    cxobj     *xp = NULL;
    char      *nsn;
    char      *n;
    yang_stmt *ys = xml_spec(xn);
    
    /* No namespace name - comply */
    if ((nsn = xml_prefix(xn)) == NULL)
	return 0;
    /* Check if NSN defined in same node */
    if (xmlns_check(xn, nsn) != NULL)
	return 0;
    /* Check if NSN defined in some ancestor */
    while ((xp = xml_parent(xn)) != NULL) {
	if (xmlns_check(xp, nsn) != NULL)
	    return 0;
    	xn = xp;
    }
    /* Check if my namespace */
    if ((n = yang_find_myprefix(ys)) != NULL && strcmp(nsn,n)==0)
	return 0;
    /* Check if any imported module */
    if (yang_find_module_by_prefix(ys, nsn) != NULL)
	return 0;
    /* Not found, error */
    clicon_err(OE_XML, ENOENT, "Namespace name %s in %s:%s not found",
	       nsn, nsn, xml_name(xn));
    return -1;
}

/*! Get parent of xnode
 * @param[in]  xn    xml node
 * @retval     parent xml node
 */
cxobj*
xml_parent(cxobj *xn)
{
    return xn->x_up;
}

/*! Set parent of xnode, parent is copied.
 * @param[in]  xn      xml node
 * @param[in]  parent  pointer to new parent xml node
 * @retval     0       OK
 */
int
xml_parent_set(cxobj *xn, 
	       cxobj *parent)
{
    xn->x_up = parent;
    return 0;
}

/*! Get xml node flags, used for internal algorithms
 * @param[in]  xn    xml node
 * @retval     flag  Flag value(s), see XML_FLAG_*
 */
uint16_t
xml_flag(cxobj   *xn, 
	 uint16_t flag)
{
    return xn->x_flags&flag;
}

/*! Set xml node flags, used for internal algorithms
 * @param[in]  xn      xml node
 * @param[in]  flag    Flag values to set, see XML_FLAG_*
 */
int
xml_flag_set(cxobj   *xn, 
	     uint16_t flag)
{
    xn->x_flags |= flag;
    return 0;
}

/*! Reset xml node flags, used for internal algorithms
 * @param[in]  xn      xml node
 * @param[in]  flag    Flag value(s) to reset, see XML_FLAG_*
 */
int
xml_flag_reset(cxobj   *xn, 
	       uint16_t flag)
{
    xn->x_flags &= ~flag;
    return 0;
}

/*! Get value of xnode
 * @param[in]  xn    xml node
 * @retval     value of xml node
 */
char*
xml_value(cxobj *xn)
{
    return xn->x_value_cb?cbuf_get(xn->x_value_cb):NULL;
}

/*! Set value of xml node, value is copied
 * @param[in]  xn    xml node
 * @param[in]  val   new value, null-terminated string, copied by function
 * @retval     -1    on error with clicon-err set
 * @retval     0     OK
 */
int
xml_value_set(cxobj *xn, 
	      char  *val)
{
    int retval = -1;
    
    if (xn->x_value_cb == NULL){
	if ((xn->x_value_cb = cbuf_new()) == NULL){
	    clicon_err(OE_XML, errno, "cbuf_new");
	    goto done;
	}
    }
    else
	cbuf_reset(xn->x_value_cb);
    cprintf(xn->x_value_cb, "%s", val);
    retval = 0;
 done:
    return retval;
}

/*! Append value of xnode, value is copied
 * @param[in]  xn    xml node
 * @param[in]  val   appended value, null-terminated string, copied by function
 * @retval     NULL  on error with clicon-err set, or if value is set to NULL
 * @retval     new value
 */
int
xml_value_append(cxobj *xn, 
		 char  *val)
{
    int retval = -1;
    
    if (xn->x_value_cb == NULL){
	if ((xn->x_value_cb = cbuf_new()) == NULL){
	    clicon_err(OE_XML, errno, "cbuf_new");
	    goto done;
	}
    }
    if (cprintf(xn->x_value_cb, "%s", val) < 0){
	clicon_err(OE_XML, errno, "cprintf");
	goto done;
    }
    retval = 0;
 done:
    return retval;
}

/*! Get type of xnode
 * @param[in]  xn    xml node
 * @retval     type of xml node
 */
enum cxobj_type
xml_type(cxobj *xn)
{
    return xn->x_type;
}

/*! Set type of xnode
 * @param[in]  xn    xml node
 * @param[in]  type  new type
 * @retval     type  old type
 */
enum cxobj_type 
xml_type_set(cxobj          *xn, 
	     enum cxobj_type type)
{
    enum cxobj_type old = xn->x_type;

    xn->x_type = type;
    return old;
}

/*! Get number of children
 * @param[in]  xn    xml node
 * @retval     number of children in XML tree
 * @see xml_child_nr_type
 * @see xml_child_nr_notype
 */
int   
xml_child_nr(cxobj *xn)
{
    return xn->x_childvec_len;
}

/*! Get number of children of EXCEPT specific type
 * @param[in]  xn    xml node
 * @param[in]  type  XML type or -1 for all
 * @retval     number of typed children in XML tree (except type)
 * @see xml_child_nr
 * @see xml_child_nr_type
 */
int   
xml_child_nr_notype(cxobj          *xn, 
		    enum cxobj_type type)
{
    cxobj *x = NULL;
    int    nr = 0;

    while ((x = xml_child_each(xn, x, -1)) != NULL) {
	if (xml_type(x) != type)
	    nr++;
    }
    return nr;
}

/*! Get number of children of specific type
 * @param[in]  xn    xml node
 * @param[in]  type  XML type or -1 for all
 * @retval     number of typed children in XML tree
 * @see xml_child_nr
 * @see xml_child_nr_notype
 */
int   
xml_child_nr_type(cxobj          *xn, 
		  enum cxobj_type type)
{
    cxobj *x = NULL;
    int    len = 0;

    while ((x = xml_child_each(xn, x, type)) != NULL) 
	len++;
    return len;
}

/*! Get a specific child
 * @param[in]  xn    xml node
 * @param[in]  i     the number of the child, eg order in children vector
 * @retval     xml   The child xml node
 * @retval     NULL  if no such child, or empty child
 * @see xml_child_i_type
 * @see xml_child_order
 */
cxobj *
xml_child_i(cxobj *xn, 
	    int    i)
{
    if (i < xn->x_childvec_len)
	return xn->x_childvec[i];
    return NULL;
}

/*! Get a specific child of a specific type
 * @param[in]  xn    xml node
 * @param[in]  i     the number of the child of specific type
 * @param[in]  type  Child type
 * @retval     child in XML tree, or NULL if no such child, or empty child
 * @see xml_child_i
 */
cxobj *
xml_child_i_type(cxobj          *xn, 
		 int             i,
		 enum cxobj_type type)
{
    cxobj *x = NULL;
    int    it = 0;
    
    while ((x = xml_child_each(xn, x, type)) != NULL) {
	if (x->x_type == type && (i == it++))
	    return x;
    }
    return NULL;
}

/*! Set specific child
 * @param[in]  xn    xml node
 * @param[in]  i     the number of the child, eg order in children vector
 * @param[in]  xc    The child to set at position i
 * @retval     0     OK
 */
cxobj *
xml_child_i_set(cxobj *xt, 
		int    i, 
		cxobj *xc)
{
    if (i < xt->x_childvec_len)
	xt->x_childvec[i] = xc;
    return 0;
}

/*! Get the order of child
 * @param[in]  xp    xml parent node
 * @param[in]  xc    the xml child to look for
 * @retval     xml   The child xml node
 * @retval     i     The order of the child
 * @retval     -1    if no such child, or empty child
 * @see xml_child_i
 */
int
xml_child_order(cxobj *xp, 
		cxobj *xc)
{
    cxobj *x = NULL;
    int    i = 0;

    while ((x = xml_child_each(xp, x, -1)) != NULL) {
	if (x == xc)
	    return i;
	i++;
    }
    return -1;
}

/*! Iterator over xml children objects
 *
 * @param[in] xparent xml tree node whose children should be iterated
 * @param[in] xprev   previous child, or NULL on init
 * @param[in] type    matching type or -1 for any
 * @code
 *   cxobj *x = NULL;
 *   while ((x = xml_child_each(x_top, x, -1)) != NULL) {
 *     ...
 *   }
 * @endcode
 * @note makes uses _x_vector_i:can be changed if list changed between calls
 * @note Never manipulate the child-list during operation or using the
 * same object recursively, the function uses an internal field to remember the
 * index used. It works as long as the same object is not iterated concurrently. 
 */
cxobj *
xml_child_each(cxobj           *xparent, 
	       cxobj           *xprev, 
	       enum cxobj_type  type)
{
    int    i;
    cxobj *xn = NULL; 

    if (xparent == NULL)
	return NULL;
    for (i=xprev?xprev->_x_vector_i+1:0; i<xparent->x_childvec_len; i++){
	xn = xparent->x_childvec[i];
	if (xn == NULL)
	    continue;
	if (type != CX_ERROR && xml_type(xn) != type)
	    continue;
	break; /* this is next object after previous */
    }
    if (i < xparent->x_childvec_len) /* found */
	xn->_x_vector_i = i;
    else
	xn = NULL;
    return xn;
}

/*! Extend child vector with one and insert xml node there
 * @note does not do anything with child, you may need to set its parent, etc
 */
static int
xml_child_append(cxobj *x, 
		 cxobj *xc)
{
    x->x_childvec_len++;
    if (x->x_childvec_len > x->x_childvec_max){
	x->x_childvec_max = x->x_childvec_max?2*x->x_childvec_max:XML_CHILDVEC_MAX_DEFAULT;
	x->x_childvec = realloc(x->x_childvec, x->x_childvec_max*sizeof(cxobj*));
	if (x->x_childvec == NULL){
	    clicon_err(OE_XML, errno, "realloc");
	    return -1;
	}
    }
    x->x_childvec[x->x_childvec_len-1] = xc;
    return 0;
}

/*! Insert child xc at position i under parent xp
 * 
 * @see xml_child_append
 * @note does not do anything with child, you may need to set its parent, etc
 */
int
xml_child_insert_pos(cxobj *xp,
		     cxobj *xc,
		     int    i)
{
    size_t size;
   
    xp->x_childvec_len++;
    if (xp->x_childvec_len > xp->x_childvec_max){
	xp->x_childvec_max = xp->x_childvec_max?2*xp->x_childvec_max:XML_CHILDVEC_MAX_DEFAULT;
	xp->x_childvec = realloc(xp->x_childvec, xp->x_childvec_max*sizeof(cxobj*));
	if (xp->x_childvec == NULL){
	    clicon_err(OE_XML, errno, "realloc");
	    return -1;
	}
    }
    size = (xml_child_nr(xp) - i - 1)*sizeof(cxobj *);
    memmove(&xp->x_childvec[i+1], &xp->x_childvec[i], size);
    xp->x_childvec[i] = xc;
    return 0;
}

/*! Set a childvec to a specific size, fill with children after
 * @code
 *   xml_childvec_set(x, 2);
 *   xml_child_i_set(x, 0, xc0)
 *   xml_child_i_set(x, 1, xc1);
 * @endcode
 */
int
xml_childvec_set(cxobj *x, 
		 int    len)
{
    x->x_childvec_len = len;
    x->x_childvec_max = len;
    if (x->x_childvec)
	free(x->x_childvec);
    if ((x->x_childvec = calloc(len, sizeof(cxobj*))) == NULL){
	clicon_err(OE_XML, errno, "calloc");
	return -1;
    }
    return 0;
}

/*! Get the children of an XML node as an XML vector
 */
cxobj **
xml_childvec_get(cxobj *x)
{
    return x->x_childvec;
}

/*! Create new xml node given a name and parent. Free with xml_free().
 *
 * @param[in]  name      Name of XML node
 * @param[in]  xp        The parent where the new xml node will be appended
 * @param[in]  spec      Yang statement of this XML or NULL.
 * @retval     xml       Created xml object if successful. Free with xml_free()
 * @retval     NULL      Error and clicon_err() called
 * @code
 *   cxobj *x;
 *   if ((x = xml_new(name, xparent, NULL)) == NULL)
 *     err;
 *   ...
 *   xml_free(x);
 * @endcode
 * @note As a rule, yspec should be given in normal Clixon calls to enable
 *       proper sorting and insert functionality. Except as follows:
 *         - type is body or attribute
 *         - Yang is unknown
 * @see xml_sort_insert
 */
cxobj *
xml_new(char      *name, 
	cxobj     *xp,
	yang_stmt *yspec)
{
    cxobj *x;
    
    if ((x = malloc(sizeof(cxobj))) == NULL){
	clicon_err(OE_XML, errno, "malloc");
	return NULL;
    }
    memset(x, 0, sizeof(cxobj));
    if ((xml_name_set(x, name)) < 0)
	return NULL;
    if (xp){
	xml_parent_set(x, xp);
	if (xml_child_append(xp, x) < 0) 
	    return NULL;
	x->_x_i = xml_child_nr(xp)-1;
    }
    x->x_spec = yspec; /* Can be NULL */
    _stats_nr++;
    return x;
}

/*! Return yang spec of node. 
 * Not necessarily set. Either has not been set yet (by xml_spec_set( or anyxml.
 */
yang_stmt *
xml_spec(cxobj *x)
{
    return x->x_spec;
}

int
xml_spec_set(cxobj     *x, 
	     yang_stmt *spec)
{
    x->x_spec = spec;
    return 0;
}

/*! Return (cached)  cligen variable value of xml node
 * @param[in]  x    XML node (body and leaf/leaf-list)
 * @retval     cv   CLIgen variable containing value of x body
 * @retval     NULL
 * @note only applicable if x is body and has yang-spec and is leaf or leaf-list
 */
cg_var *
xml_cv(cxobj *x)
{
    return x->x_cv;
}

/*! Return (cached) cligen variable value of xml node
 * @param[in]  x   XML node (body and leaf/leaf-list)
 * @param[in]  cv  CLIgen variable containing value of x body
 * @retval     0   OK
 * @note only applicable if x is body and has yang-spec and is leaf or leaf-list
 */
int
xml_cv_set(cxobj  *x, 
	   cg_var *cv)
{
    if (x->x_cv)
	cv_free(x->x_cv);
    x->x_cv = cv;
    return 0;
}

/*! Find an XML node matching name among a parent's children.
 *
 * Get first XML node directly under x_up in the xml hierarchy with
 * name "name".
 *
 * @param[in]  x_up   Base XML object
 * @param[in]  name   Node name
 *
 * @retval xmlobj     if found.
 * @retval NULL       if no such node found.
 * There are several issues with this function:
 * @note (1) Ignores prefix which means namespaces are ignored
 * @note (2) Does not differentiate between element,attributes and body. You usually want elements.
 * @note (3) Linear scalability and relies on strcmp, does not use search/key indexes
 * @note (4) Only returns first match, eg a list/leaf-list may have several children with same name
 * @see xml_find_type  A more generic function fixes (1) and (2) above
 */
cxobj *
xml_find(cxobj *x_up, 
	 char  *name)
{
    cxobj *x = NULL;

    while ((x = xml_child_each(x_up, x, -1)) != NULL) 
	if (strcmp(name, xml_name(x)) == 0)
	    break; /* x is set */
    return x;
}

/*! Append xc as child to xp. Remove xc from previous parent.
 * @param[in] xp  Parent xml node. If NULL just remove from old parent.
 * @param[in] xc  Child xml node to insert under xp
 * @retval    0   OK
 * @retval    -1  Error
 * @see xml_wrap
 * @see xml_insert
 * @note xc is not sorted correctly, need to call xml_sort on parent
 */
int
xml_addsub(cxobj *xp, 
	   cxobj *xc)
{
    int retval = -1;
    cxobj *oldp;
    int    i;
    char  *pns = NULL; /* parent namespace */
    char  *cns = NULL; /* child namespace */
    cxobj *xa;

    if ((oldp = xml_parent(xc)) != NULL){
	/* Find child order i in old parent*/
	for (i=0; i<xml_child_nr(oldp); i++)
	    if (xml_child_i(oldp, i) == xc)
		break;
	/* Remove xc from old parent */
	if (i < xml_child_nr(oldp))
	    xml_child_rm(oldp, i);
    }
    /* Add xc to new parent */
    if (xp){
	if (xml_child_append(xp, xc) < 0)
	    goto done;
	/* Set new parent in child */
	xml_parent_set(xc, xp);
	/* Ensure default namespace is not duplicated 
	 * here only remove duplicate default namespace, there may be more */
	/* 1. Get parent default namespace */
	if (xml2ns(xp, NULL, &pns) < 0)
	    goto done;
	/* 2. Get child default namespace */
	if (pns &&
	    (xa = xml_find_type(xc, NULL, "xmlns", CX_ATTR)) != NULL &&
	    (cns = xml_value(xa)) != NULL){
	    /* 3. check if same, if so remove child's */
	    if (strcmp(pns, cns) == 0)
		xml_purge(xa); 
	}
	/* clear namespace context cache of child */
	nscache_clear(xc);
#ifdef XML_EXPLICIT_INDEX
    if (xml_search_index_p(xc))
	    xml_search_child_insert(xp, xc);
#endif
    }
    retval = 0;
 done:
    return retval;
}

/*! Wrap a new node between a parent xml node (xp) and all its children
 *  Before:  xp --> xc*
 *  After:   xp --> xw --> xc*
 * @param[in] xp  Parent xml node
 * @param[in] tag Name of new xml child
 * @retval    xw  Return the new child (xw)
 * @see xml_addsub
 * @see xml_wrap  (wrap s single node)
 */
cxobj *
xml_wrap_all(cxobj *xp, 
	     char  *tag)
{
    cxobj *xw; /* new wrap node */

    if ((xw = xml_new(tag, NULL, NULL)) == NULL)
	goto done;
    while (xp->x_childvec_len)
	if (xml_addsub(xw, xml_child_i(xp, 0)) < 0)
	    goto done;
    if (xml_addsub(xp, xw) < 0)
	goto done;
  done:
    return xw;
}

/*! Wrap a new element above a single xml node (xc) with new tag 
 *  Before:  xp --> xc # specific child (xp can be NULL)
 *  After:   xp --> xt(tag) --> xc
 * @param[in] xp   Parent xml node
 * @param[in] tag  Name of new xml child
 * @retval    NULL Error
 * @retval    xc   Return the new child (xc)
 * @see xml_addsub (give the parent)
 * @see xml_wrap_all  (wrap all children of a node, not just one)
 */
cxobj *
xml_wrap(cxobj *xc, 
	 char  *tag)
{
    cxobj *xw; /* new wrap node */
    cxobj *xp; /* parent */

    xp = xml_parent(xc);
    if ((xw = xml_new(tag, xp, NULL)) == NULL)
	goto done;
    if (xml_addsub(xw, xc) < 0)
	goto done;
  done:
    return xw;
}

/*! Remove and free an xml node child from xml parent
 * @param[in]   xc          xml child node (to be removed and freed)
 * @retval      0           OK
 * @retval      -1
 * @note you cannot remove xchild in the loop (unless yoy keep track of xprev)
 * @note Linear complexity - use xml_child_rm if possible
 * @see xml_free      Free, dont remove from parent
 * @see xml_child_rm  Remove if child order is known (does not free)
 * Differs from xml_free it is removed from parent.
 */
int
xml_purge(cxobj *xc)
{
    int       retval = -1;
    int       i;
    cxobj    *xp;

    if ((xp = xml_parent(xc)) != NULL){
	/* Find child order i in parent*/
	for (i=0; i<xml_child_nr(xp); i++)
	    if (xml_child_i(xp, i) == xc)
		break;
	/* Remove xc from parent */
	if (i < xml_child_nr(xp))
	    if (xml_child_rm(xp, i) < 0)
		goto done;
    }
    xml_free(xc);	    
    retval = 0;
 done:
    return retval; 
}

/*! Remove child xml node from parent xml node. No free and child is root
 * @param[in]   xp     xml parent node
 * @param[in]   i      Number of xml child node (to remove)
 * @retval      0      OK
 * @retval      -1
 * @note you should not remove xchild in loop (unless yoy keep track of xprev)
 *
 * @see xml_rootchild
 * @see xml_rm     Remove the node itself from parent
 */
int
xml_child_rm(cxobj *xp, 
	     int    i)
{
    int    retval = -1;
    cxobj *xc = NULL;

    if ((xc = xml_child_i(xp, i)) == NULL){
	clicon_err(OE_XML, 0, "Child not found");
	goto done;
    }
#ifdef XML_EXPLICIT_INDEX
    if (xml_search_index_p(xc))
	xml_search_child_rm(xp, xc);
#endif
    xp->x_childvec[i] = NULL;
    xml_parent_set(xc, NULL);
    xp->x_childvec_len--;
    if (i<xp->x_childvec_len)
	memmove(&xp->x_childvec[i], &xp->x_childvec[i+1], (xp->x_childvec_len-i)*sizeof(cxobj*));
    retval = 0;
 done:
    return retval;
}

/*! Remove this xml node from parent xml node. No freeing and node is new root
 * @param[in]   xc     xml child node to be removed
 * @retval      0      OK
 * @retval      -1
 * @note you should not remove xchild in loop (unless yoy keep track of xprev)
 *
 * @see xml_child_rm  Remove a child of a node
 */
int
xml_rm(cxobj *xc)
{
    int    retval = -1;
    cxobj *xp;
    cxobj *x;
    int    i;

    if ((xp = xml_parent(xc)) == NULL)
	goto ok;
    /* Find child in parent XXX: search? */
    x = NULL; i = 0;
    while ((x = xml_child_each(xp, x, -1)) != NULL) {
	if (x == xc)
	    break;
	i++;
    }
    if (x != NULL)
	if (xml_child_rm(xp, i) < 0)
	    goto done;
 ok:
    retval = 0;
 done:
    return retval;
}

/*! Remove all children of specific type
 * @param[in] x    XML node
 * @param[in] type Remove all children of xn of this type
 * @retval    0    OK
 * @retval   -1    Error
 */
int
xml_rm_children(cxobj          *x,
		enum cxobj_type type)
{
    int    retval = -1;
    cxobj *xc;
    int    i;

    for (i=0; i<xml_child_nr(x);){
	xc = xml_child_i(x, i);
	if (xml_type(xc) != type){
	    i++;
	    continue;
	}
	if (xml_child_rm(x, i) < 0)
	    goto done;
	xml_free(xc);
    }
    retval = 0;
 done:
    return retval;
}

/*! Remove top XML object and all children except a single child
 * Given a root xml node, and the i:th child, remove the child from its parent
 * and return it, remove the parent and all other children. (unwrap)
 * Before: xp-->[..xc..]
 * After: xc
 * @param[in]  xp   xml parent node. Will be deleted
 * @param[in]  i    Child nr in parent child vector
 * @param[out] xcp  xml child node. New root
 * @retval     0    OK
 * @retval    -1    Error
 * @code
 *   cxobj *xt = NULL; 
 *   if (xml_parse_string("<a>2</a>", NULL, &xt) < 0)
 *      err;
 *  # Here xt will be: <top><a>2</a></top>
 *   if (xml_rootchild(xt, 0, &xt) < 0)
 *      err;
 *  # Here xt will be: <a>2</a>
 * @endcode
 * @see xml_child_rm
 * @see xml_rootchild_node  where xc is explicitly given
 */
int
xml_rootchild(cxobj  *xp, 
	      int     i,
	      cxobj **xcp)
{
    int    retval = -1;
    cxobj *xc;

    if (xml_parent(xp) != NULL){
	clicon_err(OE_XML, 0, "Parent is not root");
	goto done;
    }
    if ((xc = xml_child_i(xp, i)) == NULL){
	clicon_err(OE_XML, 0, "Child not found");
	goto done;
    }
    if (xml_child_rm(xp, i) < 0)
	goto done;
    if (xml_free(xp) < 0)
	goto done;
    *xcp = xc;
    retval = 0;
 done:
    return retval;
}

/*! Remove top XML object and all children except a single (given) child
 * Given a root xml node, remove the child from its parent
 * , remove the parent and all other children. (unwrap)
 * Before: xp-->[..xc..]
 * After: xc
 * @param[in]  xp   xml parent node. Must be root. Will be deleted
 * @param[in]  xc   xml child node. Must be a child of xp
 * @retval     0    OK
 * @retval    -1    Error
 * @see xml_rootchild  where an index is used to find xc
 */
int
xml_rootchild_node(cxobj  *xp, 
		   cxobj  *xc)
{
    int    retval = -1;
    cxobj *x;
    int    i;

    if (xml_parent(xp) != NULL){
	clicon_err(OE_XML, 0, "Parent is not root");
	goto done;
    }
    x = NULL; i = 0;
    while ((x = xml_child_each(xp, x, -1)) != NULL) {
	if (x == xc)
	    break;
	i++;
    }
    if (xml_child_rm(xp, i) < 0)
	goto done;
    if (xml_free(xp) < 0)
	goto done;
    retval = 0;
 done:
    return retval;
}

/*! Help function to sorting: enumerate all children according to present order
 * This is so that the child itself know its present order in a list.
 * When sorting by "ordered by user", the order should remain in its present
 * state.
 * A child can always compute its order functionally but it computes
 * more cycles,..
 * @param[in]  xp  Enumerate its children
 * @retval     0   OK
 * @see xml_sort
 * @see xml_enumerate_get  Call to the child to get the number
 */
int
xml_enumerate_children(cxobj *xp)
{
    cxobj *x = NULL;
    int    i = 0;

    while ((x = xml_child_each(xp, x, -1)) != NULL)
	x->_x_i = i++;
    return 0;
}

/*! Reset enumeration as done by xml_enumerate_children
 */
int
xml_enumerate_reset(cxobj *xp)
{
    cxobj *x = NULL;
 
    while ((x = xml_child_each(xp, x, -1)) != NULL)
	x->_x_i = 0;
    return 0;
}

/*! Get the enumeration of a single child set by enumeration of parent
 * @see xml_children_enumerate
 * @note that it has to be called right after xml_children_enumerate. If not,
 * there are many cases where this info is stale. 
 * @param[in]  x   A child whose parent has enumerated its children
 * @retval     n   Enumeration
 * @see xml_enumerate_children   Call to the parent to compute the nr
 */
int
xml_enumerate_get(cxobj *x)
{
    return x->_x_i;
}

/*! Get the first sub-node which is an XML body.
 * @param[in]   xn          xml tree node
 * @retval  The returned body as a pointer to the name string
 * @retval  NULL if no such node or no body in found node
 * Note, make a copy of the return value to use it properly
 * @see xml_find_body
 * Explaining picture:
 *       xt  --> xb (x_type=CX_BODY)
 *               return xb.x_value
 */
char *
xml_body(cxobj *xn)
{
    cxobj *xb = NULL;

    while ((xb = xml_child_each(xn, xb, CX_BODY)) != NULL) 
	return xml_value(xb);
    return NULL;
}

/*! Get (first) body of xml node, note could be many 
 * @param[in]   xt          xml tree node
 * Explaining picture:
 *       xt  --> xb (x_type=CX_BODY)
 *               return xb
 */
cxobj *
xml_body_get(cxobj *xt)
{
    cxobj *xb = NULL;

    while ((xb = xml_child_each(xt, xb, CX_BODY)) != NULL) 
	return xb;
    return NULL;
}

/*! Find and return the value of an xml child of specific type given prefix and name
 *
 * The value can be of an attribute only
 * @param[in]   xt          xml tree node
 * @param[in]   prefix      Prefix (namespace local name) or NULL
 * @param[in]   name        name of xml tree node (eg attr name or "body")
 * @retval      val         Pointer to the name string
 * @retval      NULL        No such node or no value in node
 * @code
 * char *str = xml_find_type_value(x, "prefix", "name", CX_ATTR);
 * @endcode
 * @note, make a copy of the return value to use it properly
 * @see xml_find_type return the xml object
 * @see xml_find_value where a body can be found as well
 */
char *
xml_find_type_value(cxobj           *xt, 
		    char            *prefix,
		    char            *name,
		    enum cxobj_type  type)
{
    cxobj *x;

    if ((x = xml_find_type(xt, prefix, name, type)) != NULL)
	return xml_value(x);
    return NULL;
}

/*! Find and return the xml child of specific type given prefix and name
 *
 * The value can be of an attribute only
 * @param[in]   xt          xml tree node
 * @param[in]   prefix      Prefix (namespace local name) or NULL
 * @param[in]   name        name of xml tree node (eg attr name or "body")
 * @param[in]   type        Matching type or -1 for any
 * @retval      val         Pointer to the name string
 * @retval      NULL        No such node or no value in node
 * @code
 * cxobj *x = xml_find_type(x, "prefix", "name", CX_ATTR);
 * @endcode
 * @see xml_find  which finds any child given name
 * @see xml_find_value where a body can be found as well
 */
cxobj *
xml_find_type(cxobj           *xt, 
	      char            *prefix,
	      char            *name,
	      enum cxobj_type  type)
{
    cxobj *x = NULL;
    int    pmatch; /* prefix match */
    char  *xprefix;     /* xprefix */
    
    while ((x = xml_child_each(xt, x, type)) != NULL) {
	if (prefix){
	    xprefix = xml_prefix(x);
	    pmatch = xprefix ? strcmp(prefix,xprefix)==0 : 0;
	}
	else
	    pmatch = 1;
	if (pmatch && strcmp(name, xml_name(x)) == 0)
	    return x;
    }
    return NULL;
}

/*! Find and return the value of a sub xml node
 *
 * The value can be of an attribute or body.
 * @param[in]   xt          xml tree node
 * @param[in]   name        name of xml tree nod (eg attr name or "body")
 * @retval      val         Pointer to the name string
 * @retval      NULL        No such node or no value in node
 *
 * Note, make a copy of the return value to use it properly
 * @see xml_find_body
 * Explaining picture:
 *       xt  --> x         
 *               x_name=name
 *               return x_value
 */
char *
xml_find_value(cxobj *xt, 
	       char  *name)
{
    cxobj *x = NULL;
    
    while ((x = xml_child_each(xt, x, -1)) != NULL) 
	if (strcmp(name, xml_name(x)) == 0)
	    return xml_value(x);
    return NULL;
}

/*! Find and return a body (string) of a sub xml node
 * @param[in]   xn          xml tree node
 * @param[in]   name        name of xml tree node
 * @retval  The returned body as a pointer to the name string
 * @retval  NULL if no such node or no body in found node
 * @note, make a copy of the return value to use it properly
 * @see xml_find_value
 * Explaining picture:
 *       xt  --> x          --> bx (x_type=CX_BODY)
 *               x_name=name    return x_value
 */
char *
xml_find_body(cxobj *xt, 
	      char  *name)
{
    cxobj *x=NULL;

    while ((x = xml_child_each(xt, x, -1)) != NULL) 
	if (strcmp(name, xml_name(x)) == 0)
	    return xml_body(x);
    return NULL;
}

/*! Find xml object with matching name and value.
 *
 * This can be useful if x is a leaf-list with many subs with same name,
 * but you need to pick the object with a specific value
 * @param[in]  xt   XML tree
 * @param[in]  name Name of child (there can be many with same name)
 * @param[in]  val  Value. Must be equal to body of child.
 * @retval     x    Child with matching name and body
 *               
 * Explaining picture:
 *       xt  --> x          --> bx (x_type=CX_BODY)
 *               x_name=name    x_value=val
 *               return x
 */
cxobj *
xml_find_body_obj(cxobj *xt, 
		  char  *name,
		  char  *val)
{
    cxobj *x = NULL;
    char  *bstr;

    while ((x = xml_child_each(xt, x, CX_ELMNT)) != NULL) {
	if (strcmp(name, xml_name(x)))
	    continue;
	if ((bstr = xml_body(x)) == NULL)
	    continue;
	if (strcmp(bstr, val) == 0)
	    break; /* x is returned */
    }
    return x;
}

/*! Free an xl sub-tree recursively, but do not remove it from parent
 * @param[in]  x  the xml tree to be freed.
 * @see xml_purge where x is also removed from parent
 */
int
xml_free(cxobj *x)
{
    int    i;
    cxobj *xc;

    if (x->x_name)
	free(x->x_name);
    if (x->x_prefix)
	free(x->x_prefix);
    if (x->x_value_cb)
	cbuf_free(x->x_value_cb);  
    for (i=0; i<x->x_childvec_len; i++){
	if ((xc = x->x_childvec[i]) != NULL){
	    xml_free(xc);
	    x->x_childvec[i] = NULL;
	}
    }
    if (x->x_childvec)
	free(x->x_childvec);
    if (x->x_cv)
	cv_free(x->x_cv);
    if (x->x_ns_cache)
	xml_nsctx_free(x->x_ns_cache);
#ifdef XML_EXPLICIT_INDEX
    xml_search_index_free(x);
#endif
    free(x);
    _stats_nr--;
    return 0;
}

/*------------------------------------------------------------------------
 * XML printing functions. Output a parse tree to file, string cligen buf
 *------------------------------------------------------------------------*/

/*! Print an XML tree structure to an output stream and encode chars "<>&"
 *
 * @param[in]   f           UNIX output stream
 * @param[in]   xn          clicon xml tree
 * @param[in]   level       how many spaces to insert before each line
 * @param[in]   prettyprint insert \n and spaces tomake the xml more readable.
 * @see clicon_xml2cbuf
 * One can use clicon_xml2cbuf to get common code, but using fprintf is
 * much faster than using cbuf and then printing that,...
 */
int
clicon_xml2file(FILE  *f, 
		cxobj *x, 
		int    level, 
		int    prettyprint)
{
    int    retval = -1;
    char  *name;
    char  *namespace;
    cxobj *xc;
    int    hasbody;
    int    haselement;
    char  *val;
    char  *encstr = NULL; /* xml encoded string */
    
    if (x == NULL)
	goto ok;
    name = xml_name(x);
    namespace = xml_prefix(x);
    switch(xml_type(x)){
    case CX_BODY:
	if ((val = xml_value(x)) == NULL) /* incomplete tree */
	    break;
	if (xml_chardata_encode(&encstr, "%s", val) < 0)
	    goto done;
	fprintf(f, "%s", encstr);
	break;
    case CX_ATTR:
	fprintf(f, " ");
	if (namespace)
	    fprintf(f, "%s:", namespace);
	fprintf(f, "%s=\"%s\"", name, xml_value(x));
	break;
    case CX_ELMNT:
	fprintf(f, "%*s<", prettyprint?(level*XML_INDENT):0, "");
	if (namespace)
	    fprintf(f, "%s:", namespace);
	fprintf(f, "%s", name);
	hasbody = 0;
	haselement = 0;
	xc = NULL;
	/* print attributes only */
	while ((xc = xml_child_each(x, xc, -1)) != NULL) {
	    switch (xml_type(xc)){
	    case CX_ATTR:
		if (clicon_xml2file(f, xc, level+1, prettyprint) <0)
		    goto done;
		break;
	    case CX_BODY:
		hasbody=1;
		break;
	    case CX_ELMNT:
		haselement=1;
		break;
	    default:
		break;
	    }
	}
	/* Check for special case <a/> instead of <a></a>:
	 * Ie, no CX_BODY or CX_ELMNT child.
	 */
	if (hasbody==0 && haselement==0) 
	    fprintf(f, "/>");
	else{
	    fprintf(f, ">");
	    if (prettyprint && hasbody == 0)
		    fprintf(f, "\n");
	    xc = NULL;
	    while ((xc = xml_child_each(x, xc, -1)) != NULL) {
		if (xml_type(xc) != CX_ATTR)
		    if (clicon_xml2file(f, xc, level+1, prettyprint) <0)
			goto done;
	    }
	    if (prettyprint && hasbody==0)
		fprintf(f, "%*s", level*XML_INDENT, "");
	    fprintf(f, "</");
	    if (namespace)
		fprintf(f, "%s:", namespace);
	    fprintf(f, "%s>", name);
	}
	if (prettyprint)
	    fprintf(f, "\n");
	break;
    default:
	break;
    }/* switch */
 ok:
    retval = 0;
 done:
    if (encstr)
	free(encstr);
    return retval;
}

/*! Print an XML tree structure to an output stream
 *
 * Uses clicon_xml2file internally
 *
 * @param[in]   f           UNIX output stream
 * @param[in]   xn          clicon xml tree
 * @see clicon_xml2cbuf
 * @see clicon_xml2file
 */
int
xml_print(FILE  *f, 
	  cxobj *xn)
{
    return clicon_xml2file(f, xn, 0, 1);
}

/*! Print an XML tree structure to a cligen buffer and encode chars "<>&"
 *
 * @param[in,out] cb          Cligen buffer to write to
 * @param[in]     xn          Clicon xml tree
 * @param[in]     level       Indentation level for prettyprint
 * @param[in]     prettyprint insert \n and spaces tomake the xml more readable.
 * @param[in]     depth       Limit levels of child resources: -1 is all, 0 is none, 1 is node itself
 *
 * @code
 * cbuf *cb;
 * cb = cbuf_new();
 * if (clicon_xml2cbuf(cb, xn, 0, 1, -1) < 0)
 *   goto err;
 * fprintf(stderr, "%s", cbuf_get(cb));
 * cbuf_free(cb);
 * @endcode
 * @see  clicon_xml2file
 */
int
clicon_xml2cbuf(cbuf   *cb, 
		cxobj  *x, 
		int     level,
		int     prettyprint,
		int32_t depth)
{
    int    retval = -1;
    cxobj *xc;
    char  *name;
    int    hasbody;
    int    haselement;
    char  *namespace;
    char  *encstr = NULL; /* xml encoded string */
    char  *val;
    
    if (depth == 0)
	goto ok;
    name = xml_name(x);
    namespace = xml_prefix(x);
    switch(xml_type(x)){
    case CX_BODY:
	if ((val = xml_value(x)) == NULL) /* incomplete tree */
	    break;
	if (xml_chardata_encode(&encstr, "%s", val) < 0)
	    goto done;
	cprintf(cb, "%s", encstr);
	break;
    case CX_ATTR:
	cprintf(cb, " ");
	if (namespace)
	    cprintf(cb, "%s:", namespace);
	cprintf(cb, "%s=\"%s\"", name, xml_value(x));
	break;
    case CX_ELMNT:
	cprintf(cb, "%*s<", prettyprint?(level*XML_INDENT):0, "");
	if (namespace)
	    cprintf(cb, "%s:", namespace);
	cprintf(cb, "%s", name);
	hasbody = 0;
	haselement = 0;
	xc = NULL;
	/* print attributes only */
	while ((xc = xml_child_each(x, xc, -1)) != NULL) 
	    switch (xml_type(xc)){
	    case CX_ATTR:
		if (clicon_xml2cbuf(cb, xc, level+1, prettyprint, -1) < 0)
		    goto done;
		break;
	    case CX_BODY:
		hasbody=1;
		break;
	    case CX_ELMNT:
		haselement=1;
		break;
	    default:
		break;
	    }
	/* Check for special case <a/> instead of <a></a> */
	if (hasbody==0 && haselement==0) 
	    cprintf(cb, "/>");
	else{
	    cprintf(cb, ">");
	    if (prettyprint && hasbody == 0)
		cprintf(cb, "\n");
	    xc = NULL;
	    while ((xc = xml_child_each(x, xc, -1)) != NULL) 
		if (xml_type(xc) != CX_ATTR)
		    if (clicon_xml2cbuf(cb, xc, level+1, prettyprint, depth-1) < 0)
			goto done;
	    if (prettyprint && hasbody == 0)
		cprintf(cb, "%*s", level*XML_INDENT, "");
	    cprintf(cb, "</");
	    if (namespace)
		cprintf(cb, "%s:", namespace);
	    cprintf(cb, "%s>", name);
	}
	if (prettyprint)
	    cprintf(cb, "\n");
	break;
    default:
	break;
    }/* switch */
 ok:
    retval = 0;
 done:
    if (encstr)
	free(encstr);
    return retval;
}
/*! Print actual xml tree datastructures (not xml), mainly for debugging
 * @param[in,out] cb          Cligen buffer to write to
 * @param[in]     xn          Clicon xml tree
 * @param[in]     level       Indentation level
 */
int
xmltree2cbuf(cbuf  *cb, 
	     cxobj *x,
	     int    level)
{
    cxobj *xc;
    int    i;

    for (i=0; i<level*XML_INDENT; i++)
	cprintf(cb, " ");
    if (xml_type(x) != CX_BODY)
	cprintf(cb, "%s", xml_type2str(xml_type(x)));
    if (xml_prefix(x)==NULL)
	cprintf(cb, " %s", xml_name(x));
    else
	cprintf(cb, " %s:%s", xml_prefix(x), xml_name(x));
    if (xml_value(x))
	cprintf(cb, " value:\"%s\"", xml_value(x));
    if (x->x_flags)
	cprintf(cb, " flags:0x%x", x->x_flags);
    if (xml_child_nr(x))
	cprintf(cb, " {");
    cprintf(cb, "\n");
    xc = NULL;
    while ((xc = xml_child_each(x, xc, -1)) != NULL) 
	xmltree2cbuf(cb, xc, level+1);
    if (xml_child_nr(x)){
	for (i=0; i<level*XML_INDENT; i++)
	    cprintf(cb, " ");
	cprintf(cb, "}\n");
    }
    return 0;
}

/*--------------------------------------------------------------------
 * XML parsing functions. Create XML parse tree from string and file.
 *--------------------------------------------------------------------*/
/*! Common internal xml parsing function string to parse-tree
 *
 * Given a string containing XML, parse into existing XML tree and return
 * @param[in]     str   Pointer to string containing XML definition. 
 * @param[in]     yb    How to bind yang to XML top-level when parsing
 * @param[in]     yspec Yang specification (only if bind is TOP or CONFIG)
 * @param[in,out] xtop  Top of XML parse tree. Assume created. Holds new tree.
 * @param[out]    xerr  Reason for failure (yang assignment not made)
 * @retval        1     Parse OK and all yang assignment made
 * @retval        0     Parse OK but yang assigment not made (or only partial) and xerr set
 * @retval       -1     Error with clicon_err called. Includes parse error
 * @see xml_parse_file
 * @see xml_parse_string
 * @see xml_parse_va
 * @see _json_parse
 * @note special case is empty XML where the parser is not invoked.
 */
static int 
_xml_parse(const char    *str, 
	   enum yang_bind yb,
	   yang_stmt     *yspec,
	   cxobj         *xt,
	   cxobj        **xerr)
{
    int             retval = -1;
    clixon_xml_yacc xy = {0,};
    cxobj          *x;
    int             ret;
    int             failed = 0; /* yang assignment */
    int             i;

    clicon_debug(1, "%s %s", __FUNCTION__, str);
    if (strlen(str) == 0)
	return 0; /* OK */
    if (xt == NULL){
	clicon_err(OE_XML, errno, "Unexpected NULL XML");
	return -1;	
    }
    if ((xy.xy_parse_string = strdup(str)) == NULL){
	clicon_err(OE_XML, errno, "strdup");
	return -1;
    }
    xy.xy_xtop = xt;
    xy.xy_xparent = xt;
    xy.xy_yspec = yspec;
    if (clixon_xml_parsel_init(&xy) < 0)
	goto done;    
    if (clixon_xml_parseparse(&xy) != 0)  /* yacc returns 1 on error */
	goto done;
    /* Purge all top-level body objects */
    x = NULL;
    while ((x = xml_find_type(xt, NULL, "body", CX_BODY)) != NULL)
	xml_purge(x);
    /* Traverse new objects */
    for (i = 0; i < xy.xy_xlen; i++) {
	x = xy.xy_xvec[i];
	/* Verify namespaces after parsing */
	if (xml_apply0(x, CX_ELMNT, xml_localname_check, NULL) < 0)
	    goto done;
	/* Populate, ie associate xml nodes with yang specs 
	 */
	switch (yb){
	case YB_RPC:
	case YB_UNKNOWN:
	case YB_NONE:
	    break;
	case YB_PARENT:
	    /* xt:n         Has spec
	     * x:   <a> <-- populate from parent
	     */
	    if ((ret = xml_spec_populate0_parent(x, xerr)) < 0)
		goto done;
	    if (ret == 0)
		failed++;
	    break;
	case YB_TOP:
	    /* xt:<top>     nospec
	     * x:   <a> <-- populate from modules
	     */
#ifdef XMLDB_CONFIG_HACK
	    if (strcmp(xml_name(x),"config") == 0){
		/* xt:<top>         nospec
		 * x:   <config>
		 *         <a>  <-- populate from modules
		 */
		if ((ret = xml_spec_populate(x, yspec, xerr)) < 0)
		    goto done;
	    }
	    else
#endif
	    if ((ret = xml_spec_populate0(x, yspec, xerr)) < 0)
		goto done;
	    if (ret == 0)
		failed++;
	    break;
	}
    }
    /* Sort the complete tree after parsing. Sorting is less meaningful if Yang not bound */
    if (xml_apply0(xt, CX_ELMNT, xml_sort, NULL) < 0)
	goto done;
    retval = (failed==0) ? 1 : 0;
  done:
    clixon_xml_parsel_exit(&xy);
    if (xy.xy_parse_string != NULL)
	free(xy.xy_parse_string);
    if (xy.xy_xvec)
	free(xy.xy_xvec);
    return retval; 
}

/*! Read an XML definition from file and parse it into a parse-tree. 
 *
 * @param[in]     fd  A file descriptor containing the XML file (as ASCII characters)
 * @param[in]     yspec   Yang specification, or NULL
 * @param[in,out] xt   Pointer to XML parse tree. If empty, create.
 * @retval        1     Parse OK and all yang assignment made
 * @retval        0     Parse OK but yang assigment not made (or only partial)
 * @retval       -1     Error with clicon_err called. Includes parse error *
 * @code
 *  cxobj *xt = NULL;
 *  int    fd;
 *  fd = open(filename, O_RDONLY);
 *  xml_parse_file(fd, yspec, &xt);
 *  xml_free(xt);
 * @endcode
 * @see xml_parse_string
 * @see xml_parse_va
 * @note, If xt empty, a top-level symbol will be added so that <tree../> will be:  <top><tree.../></tree></top>
 * @note May block on file I/O
 * @see xml_parse_file2 for a more advanced API
 */
int 
xml_parse_file(int        fd, 
	       yang_stmt *yspec,
	       cxobj    **xt)
{
    enum yang_bind yb = YB_PARENT;

    if (xt==NULL){
	clicon_err(OE_XML, EINVAL, "xt is NULL");
	return -1;
    }
    if (*xt==NULL)
	yb = YB_TOP;
    return xml_parse_file2(fd, yb, yspec, NULL, xt, NULL);
}

/*! FSM to detect substring
 */
static inline int
FSM(char *tag, 
    char  ch, 
    int   state)
{
    if (tag[state] == ch)
	return state+1;
    else
	return 0;
}

/*! Read an XML definition from file and parse it into a parse-tree, advanced API
 *
 * @param[in]     fd    A file descriptor containing the XML file (as ASCII characters)
 * @param[in]     yb    How to bind yang to XML top-level when parsing
 * @param[in]     yspec Yang specification (only if bind is TOP or CONFIG)
 * @param[in]     endtag  Read until encounter "endtag" in the stream, or NULL
 * @param[in,out] xt    Pointer to XML parse tree. If empty, create.
 * @retval        1     Parse OK and all yang assignment made
 * @retval        0     Parse OK but yang assigment not made (or only partial) and xerr set
 * @retval       -1     Error with clicon_err called. Includes parse error
 *
 * @code
 *  cxobj *xt = NULL;
 *  cxobj *xerr = NULL;
 *  int    fd;
 *  fd = open(filename, O_RDONLY);
 *  if ((ret = xml_parse_file2(fd, YB_TOP, yspec, "</config>", &xt, &xerr)) < 0)
 *    err;
 *  xml_free(xt);
 * @endcode
 * @see xml_parse_string
 * @see xml_parse_file
 * @note, If xt empty, a top-level symbol will be added so that <tree../> will be:  <top><tree.../></tree></top>
 * @note May block on file I/O
 */
int 
xml_parse_file2(int            fd, 
		enum yang_bind yb,
		yang_stmt     *yspec,
		char          *endtag,
		cxobj        **xt,
		cxobj        **xerr)
{
    int   retval = -1;
    int   ret;
    int   len = 0;
    char  ch;
    char *xmlbuf = NULL;
    char *ptr;
    int   xmlbuflen = BUFLEN; /* start size */
    int   endtaglen = 0;
    int   state = 0;
    int   oldxmlbuflen;
    int   failed = 0;

    if (endtag != NULL)
	endtaglen = strlen(endtag);
    if ((xmlbuf = malloc(xmlbuflen)) == NULL){
	clicon_err(OE_XML, errno, "malloc");
	goto done;
    }
    memset(xmlbuf, 0, xmlbuflen);
    ptr = xmlbuf;
    while (1){
	if ((ret = read(fd, &ch, 1)) < 0){
	    clicon_err(OE_XML, errno, "read: [pid:%d]", 
		    (int)getpid());
	    break;
	}
	if (ret != 0){
	    if (endtag)
		state = FSM(endtag, ch, state);
	    xmlbuf[len++] = ch;
	}
	if (ret == 0 ||
	    (endtag && (state == endtaglen))){
	    state = 0;
	    if (*xt == NULL)
		if ((*xt = xml_new(XML_TOP_SYMBOL, NULL, NULL)) == NULL)
		    goto done;
	    if ((ret = _xml_parse(ptr, yb, yspec, *xt, xerr)) < 0)
		goto done;
	    if (ret == 0)
		failed++;
	    break;
	}
	if (len>=xmlbuflen-1){ /* Space: one for the null character */
	    oldxmlbuflen = xmlbuflen;
	    xmlbuflen *= 2;
	    if ((xmlbuf = realloc(xmlbuf, xmlbuflen)) == NULL){
		clicon_err(OE_XML, errno, "realloc");
		goto done;
	    }
	    memset(xmlbuf+oldxmlbuflen, 0, xmlbuflen-oldxmlbuflen);
	    ptr = xmlbuf;
	}
    } /* while */
    retval = (failed==0) ? 1 : 0;
 done:
    if (retval < 0 && *xt){
	free(*xt);
	*xt = NULL;
    }
    if (xmlbuf)
	free(xmlbuf);
    return retval;
}

/*! Read an XML definition from string and parse it into a parse-tree, advanced API
 *
 * @param[in]     str   String containing XML definition. 
 * @param[in]     yb    How to bind yang to XML top-level when parsing
 * @param[in]     yspec Yang specification, or NULL
 * @param[in,out] xt    Pointer to XML parse tree. If empty will be created.
 * @param[out]    xerr  Reason for failure (yang assignment not made)
 * @retval        1     Parse OK and all yang assignment made
 * @retval        0     Parse OK but yang assigment not made (or only partial)
 * @retval       -1     Error with clicon_err called. Includes parse error
 *
 * @code
 *  cxobj *xt = NULL;
 *  cxobj *xerr = NULL;
 *  if (xml_parse_string2(str, YB_TOP, yspec, &xt, &xerr) < 0)
 *    err;
 *  if (xml_rootchild(xt, 0, &xt) < 0) # If you want to remove TOP
 *    err;
 * @endcode
 * @see xml_parse_file
 * @see xml_parse_va
 * @note You need to free the xml parse tree after use, using xml_free()
 * @note If empty on entry, a new TOP xml will be created named "top"
 */
int 
xml_parse_string2(const char    *str, 
		  enum yang_bind yb,
		  yang_stmt     *yspec,
		  cxobj        **xt,
		  cxobj        **xerr)
{
    if (xt==NULL){
	clicon_err(OE_XML, EINVAL, "xt is NULL");
	return -1;
    }
    if (*xt == NULL){
	if ((*xt = xml_new(XML_TOP_SYMBOL, NULL, NULL)) == NULL)
	    return -1;
    }
    return _xml_parse(str, yb, yspec, *xt, xerr);
}

/*! Read an XML definition from string and parse it into a parse-tree
 *
 * @param[in]     str   String containing XML definition. 
 * @param[in]     yspec Yang specification, or NULL
 * @param[in,out] xt    Pointer to XML parse tree. If empty will be created.
 * @retval        1     Parse OK and all yang assignment made
 * @retval        0     Parse OK but yang assigment not made (or only partial)
 * @retval       -1     Error with clicon_err called. Includes parse error
 *
 * @code
 *  cxobj *xt = NULL;
 *  if (xml_parse_string(str, yspec, &xt) < 0)
 *    err;
 *  if (xml_rootchild(xt, 0, &xt) < 0) # If you want to remove TOP
 *    err;
 * @endcode
 * @see xml_parse_file
 * @see xml_parse_va
 * @note You need to free the xml parse tree after use, using xml_free()
 * @note If xt is empty on entry, a new TOP xml will be created named "top" and yang binding 
 *       assumed to be TOP
 */
int 
xml_parse_string(const char *str, 
		 yang_stmt  *yspec,
		 cxobj     **xt)
{
    enum yang_bind yb = YB_PARENT;

    if (xt==NULL){
	clicon_err(OE_XML, EINVAL, "xt is NULL");
	return -1;
    }
    if (*xt == NULL){
	yb = YB_TOP; /* ad-hoc #1 */
	if ((*xt = xml_new(XML_TOP_SYMBOL, NULL, NULL)) == NULL)
	    return -1;
    }
    else{
	if (xml_spec(*xt) == NULL)
	    yb = YB_TOP;  /* ad-hoc #2 */
    }
    return _xml_parse(str, yb, yspec, *xt, NULL);
}

/*! Read XML from var-arg list and parse it into xml tree
 *
 * Utility function using stdarg instead of static string.
 * @param[in,out] xtop   Top of XML parse tree. If it is NULL, top element 
                         called 'top' will be created. Call xml_free() after use
 * @param[in]     yspec  Yang specification, or NULL
 * @param[in]     format Format string for stdarg according to printf(3)
 * @retval        1      Parse OK and all yang assignment made
 * @retval        0      Parse OK but yang assigment not made (or only partial)
 * @retval       -1      Error with clicon_err called. Includes parse error
 *
 * @code
 *  cxobj *xt = NULL;
 *  if (xml_parse_va(&xt, NULL, "<xml>%d</xml>", 22) < 0)
 *    err;
 *  xml_free(xt);
 * @endcode
 * @see xml_parse_string
 * @see xml_parse_file
 * @note If vararg list is empty, consider using xml_parse_string()
 */
int 
xml_parse_va(cxobj     **xtop,
	     yang_stmt  *yspec,		 
	     const char *format, ...)
{
    int     retval = -1;
    va_list args;
    char   *str = NULL;
    int     len;

    va_start(args, format);
    len = vsnprintf(NULL, 0, format, args) + 1;
    va_end(args);
    if ((str = malloc(len)) == NULL){
	clicon_err(OE_UNIX, errno, "malloc");
	goto done;
    }
    memset(str, 0, len);
    va_start(args, format);
    len = vsnprintf(str, len, format, args) + 1;
    va_end(args);
    retval = xml_parse_string(str, yspec, xtop); /* xml_parse_string2 */
 done:
    if (str)
	free(str);
    return retval;
}

/*! Copy single xml node from x0 to x1 without copying children
 * @param[in]  x0  Source XML tree
 * @param[in]  x1  Destination XML tree (must exist)
 * @retval     0   OK
 * @retval    -1   Error
 */
int
xml_copy_one(cxobj *x0, 
	     cxobj *x1)
{
    int   retval = -1;
    char *s;
    
    xml_type_set(x1, xml_type(x0));
    if ((s = xml_value(x0))){ /* malloced string */
	if (xml_value_set(x1, s) < 0)
	    goto done;
    }
    if ((s = xml_name(x0))) /* malloced string */
	if ((xml_name_set(x1, s)) < 0)
	    goto done;
    if ((s = xml_prefix(x0))) /* malloced string */
	if ((xml_prefix_set(x1, s)) < 0)
	    goto done;
    xml_spec_set(x1, xml_spec(x0));
    retval = 0;
 done:
    return retval;
}

/*! Copy xml tree x0 to other existing tree x1
 *
 * x1 should be a created placeholder. If x1 is non-empty,
 * the copied tree is appended to the existing tree.
 * @param[in]  x0  Source XML tree
 * @param[in]  x1  Destination XML tree (must exist)
 * @retval     0   OK
 * @retval    -1   Error
 * @code
 *   x1 = xml_new("new", xparent, NULL);
 *   if (xml_copy(x0, x1) < 0)
 *      err;
 * @endcode
 * @see xml_dup
 */
int 
xml_copy(cxobj *x0, 
	 cxobj *x1)
{
    int    retval = -1;
    cxobj *x;
    cxobj *xcopy;

    if (xml_copy_one(x0, x1) <0)
	goto done;
    x = NULL;
    while ((x = xml_child_each(x0, x, -1)) != NULL) {
	if ((xcopy = xml_new(xml_name(x), x1, xml_spec(x))) == NULL)
	    goto done;
	if (xml_copy(x, xcopy) < 0) /* recursion */
	    goto done;
    }
    retval = 0;
  done:
    return retval;
}

/*! Create and return a copy of xml tree.
 *
 * @code
 *   cxobj *x1;
 *   x1 = xml_dup(x0);
 * @endcode
 * Note, returned tree should be freed as: xml_free(x1)
 * @see xml_cp
 */
cxobj *
xml_dup(cxobj *x0)
{
    cxobj *x1;

    if ((x1 = xml_new("new", NULL, xml_spec(x0))) == NULL)
	return NULL;
    if (xml_copy(x0, x1) < 0)
	return NULL;
    return x1;
}

#if 1 /* XXX At some point migrate this code to the clixon_xml_vec.[ch] API */
/*! Copy XML vector from vec0 to vec1
 * @param[in]  vec0    Source XML tree vector
 * @param[in]  len0    Length of source XML tree vector
 * @param[out] vec1    Destination XML tree vector
 * @param[out] len1    Length of destination XML tree vector
 */
int
cxvec_dup(cxobj  **vec0, 
	  size_t   len0, 
	  cxobj ***vec1, 
	  size_t  *len1)
{
    int retval = -1;

    *len1 = len0;
    if ((*vec1 = calloc(len0, sizeof(cxobj*))) == NULL)
	goto done;
    memcpy(*vec1, vec0, len0*sizeof(cxobj*));
    retval = 0;
 done:
    return retval;
}

/*! Append a new xml tree to an existing xml vector last in the list
 * @param[in]      x      XML tree (append this to vector)
 * @param[in,out]  vec    XML tree vector
 * @param[in,out]  len    Length of XML tree vector
 * @retval         0      OK
 * @retval        -1      Error
 * @code
 *  cxobj  **xvec = NULL;
 *  size_t   xlen = 0;
 *  cxobj   *x; 
 *
 *  if (cxvec_append(x, &xvec, &xlen) < 0) 
 *     err;
 *  if (xvec)
 *     free(xvec);
 * @endcode
 * @see cxvec_prepend
 */
int
cxvec_append(cxobj   *x, 
	     cxobj ***vec, 
	     size_t  *len)
{
    int retval = -1;

    if ((*vec = realloc(*vec, sizeof(cxobj *) * (*len+1))) == NULL){
	clicon_err(OE_XML, errno, "realloc");
	goto done;
    }
    (*vec)[(*len)++] = x;
    retval = 0;
 done:
    return retval;
}

/*! Prepend a new xml tree to an existing xml vector first in the list
 * @param[in]      x      XML tree (append this to vector)
 * @param[in,out]  vec    XML tree vector
 * @param[in,out]  len    Length of XML tree vector
 * @retval         0      OK
 * @retval        -1      Error
 * @code
 *  cxobj  **xvec = NULL;
 *  size_t   xlen = 0;
 *  cxobj   *x; 
 *
 *  if (cxvec_append(x, &xvec, &xlen) < 0) 
 *     err;
 *  if (xvec)
 *     free(xvec);
 * @endcode
 * @see cxvec_prepend
 */
int
cxvec_prepend(cxobj   *x, 
	     cxobj ***vec, 
	     size_t  *len)
{
    int retval = -1;

    if ((*vec = realloc(*vec, sizeof(cxobj *) * (*len+1))) == NULL){
	clicon_err(OE_XML, errno, "realloc");
	goto done;
    }
    memmove(&(*vec)[1], &(*vec)[0], sizeof(cxobj *) * (*len));
    (*vec)[0] = x;
    (*len)++;
    retval = 0;
 done:
    return retval;
}
#endif

/*! Apply a function call recursively on all xml node children recursively
 * Recursively traverse all xml nodes in a parse-tree and apply fn(arg) for 
 * each object found. The function is called with the xml node and an 
 * argument as args.
 * The tree is traversed depth-first, which at least guarantees that a parent is
 * traversed before a child.
 * @param[in]  xn   XML node
 * @param[in]  type Matching type or -1 for any
 * @param[in]  fn   Callback
 * @param[in]  arg  Argument
 * @retval    -1    Error, aborted at first error encounter
 * @retval     0    OK, all nodes traversed (subparts may have been skipped)
 * @retval     1    OK, aborted on first fn returned 1
 *
 * @code
 * int x_fn(cxobj *x, void *arg)
 * {
 *   return 0;
 * }
 * xml_apply(xn, CX_ELMNT, x_fn, NULL);
 * @endcode
 * @note do not delete or move around any children during this function
 * @note return value > 0 aborts the traversal
 * @see xml_apply0 including top object
 * @see xml_apply_ancestor for marking all parents recursively
 */
int
xml_apply(cxobj          *xn, 
	  enum cxobj_type type, 
	  xml_applyfn_t   fn, 
	  void           *arg)
{
    int        retval = -1;
    cxobj     *x;
    int        ret;

    x = NULL;
    while ((x = xml_child_each(xn, x, type)) != NULL) {
	if ((ret = fn(x, arg)) < 0)
	    goto done;
	if (ret == 2)
	    continue; /* Abort this node, dont recurse */
	else if (ret == 1){
	    retval = 1;
	    goto done;
	}
	if ((ret = xml_apply(x, type, fn, arg)) < 0)
	    goto done;
	if (ret == 1){
	    retval = 1;
	    goto done;
	}
    }
    retval = 0;
  done:
    return retval;   
}

/*! Apply a function call on top object and all xml node children recursively 
 * @param[in]  xn   XML node
 * @param[in]  type Matching type or -1 for any
 * @param[in]  fn   Callback
 * @param[in]  arg  Argument
 * @retval    -1    Error, aborted at first error encounter
 * @retval     0    OK, all nodes traversed (subparts may have been skipped)
 * @retval     1    OK, aborted on first fn returned 1
 * @see xml_apply not including top object
 */
int
xml_apply0(cxobj          *xn, 
	  enum cxobj_type type, 
	  xml_applyfn_t   fn, 
	  void           *arg)
{
    int        retval = -1;
    int        ret;

    if ((ret = fn(xn, arg)) < 0) /* -1, 0, 1, 2 */
	goto done;
    if (ret == 1)
	retval = 1;
    else  if (ret > 1)
	retval = 0;
    else /* 0 */
	retval = xml_apply(xn, type, fn, arg);
  done:
    return retval;   
}

/*! Apply a function call recursively on all ancestors
 * Recursively traverse upwards to all ancestor nodes in a parse-tree and apply fn(arg) for 
 * each object found. The function is called with the xml node and an 
 * argument as args.
 * @param[in]  xn   XML node
 * @param[in]  fn   Callback
 * @param[in]  arg  Argument
 * @retval    -1    Error, aborted at first error encounter
 * @retval     0    OK, all nodes traversed
 * @retval     n    OK, aborted at first encounter of first match
 * @code
 * int x_fn(cxobj *x, void *arg)
 * {
 *   return 0;
 * }
 * xml_apply_ancestor(xn, x_fn, NULL);
 * @endcode
 * @see xml_apply
 * @note do not delete or move around any children during this function
 * @note It does not apply fn to the root node,..
 */
int
xml_apply_ancestor(cxobj          *xn, 
		   xml_applyfn_t   fn, 
		   void           *arg)
{
    int        retval = -1;
    cxobj     *xp = NULL;
    int        ret;

    while ((xp = xml_parent(xn)) != NULL) {
	if (fn(xp, arg) < 0)
	    goto done;
	if ((ret = xml_apply_ancestor(xp, fn, arg)) < 0)
	    goto done;
	if (ret > 0){
	    retval = ret;
	    goto done;
	}
	xn = xp;
    }
    retval = 0;
  done:
    return retval;   
}

/*! Is xpp ancestor of x?
 * @param[in]   x       XML node
 * @param[in]   xpp     Potential ancestor of x in XML tree
 * @retval      0       No, xpp is not ancestor of x
 * @retval      1       Yes, xpp is ancestor of x
 */
int
xml_isancestor(cxobj *x,
	       cxobj *xpp)
{
    cxobj     *xp = NULL;
    cxobj     *xn = NULL;

    xn = x;
    while ((xp = xml_parent(xn)) != NULL) {
	if (xp == xpp)
	    return 1;
	xn = xp;
    }
    return 0;
}

/*! Generic parse function for xml values
 * @param[in]   xb       xml tree body node, ie containing a value to be parsed
 * @param[in]   type     Type of value to be parsed in value
 * @param[out]  cvp      CLIgen variable containing the parsed value
 * @note free cv with cv_free after use.
 * @see xml_body_int32   etc, for type-specific parse functions
 * @note range check failure returns 0
 */
int
xml_body_parse(cxobj       *xb,
	       enum cv_type type,
	       cg_var     **cvp)
{
    int     retval = -1;
    cg_var *cv = NULL;
    int     cvret;
    char   *bstr;
    char   *reason = NULL;

    if ((bstr = xml_body(xb)) == NULL){
	clicon_err(OE_XML, 0, "No body found");
	goto done;
    }
    if ((cv = cv_new(type)) == NULL){
	clicon_err(OE_XML, errno, "cv_new");
	goto done;
    }
    if ((cvret = cv_parse1(bstr, cv, &reason)) < 0){
	clicon_err(OE_XML, errno, "cv_parse");
	goto done;
    }
    if (cvret == 0){  /* parsing failed */
	clicon_err(OE_XML, errno, "Parsing CV: %s", reason);
	if (reason)
	    free(reason);
    }
    *cvp = cv;
    retval = 0;
 done:
    if (retval < 0 && cv != NULL)
	cv_free(cv);
    return retval;
}

/*! Parse an xml body as int32
 * The real parsing functions are in the cligen code
 * @param[in]   xb          xml tree body node, ie containing a value to be parsed
 * @param[out]  val         Value after parsing
 * @retval      0           OK, parsed value in 'val'
 * @retval     -1           Error, one of: body not found, parse error, 
 *                          alloc error.
 * @note extend to all other cligen var types and generalize
 * @note use yang type info?
 * @note range check failure returns 0
 */
int
xml_body_int32(cxobj    *xb,
	       int32_t *val)
{
    cg_var *cv = NULL;

    if (xml_body_parse(xb, CGV_INT32, &cv) < 0)
	return -1;
    *val = cv_int32_get(cv);
    cv_free(cv);
    return 0;
}

/*! Parse an xml body as uint32
 * The real parsing functions are in the cligen code
 * @param[in]   xb          xml tree body node, ie containing a value to be parsed
 * @param[out]  val         Value after parsing
 * @retval      0           OK, parsed value in 'val'
 * @retval     -1           Error, one of: body not found, parse error, 
 *                          alloc error.
 * @note extend to all other cligen var types and generalize
 * @note use yang type info?
 * @note range check failure returns 0
 */
int
xml_body_uint32(cxobj    *xb,
		uint32_t *val)
{
    cg_var *cv = NULL;

    if (xml_body_parse(xb, CGV_UINT32, &cv) < 0)
	return -1;
    *val = cv_uint32_get(cv);
    cv_free(cv);
    return 0;
}

/*! Map xml operation from string to enumeration
 * @param[in]   opstr  String, eg "merge"
 * @param[out]  op     Enumeration, eg OP_MERGE
 * @code
 *   enum operation_type op;
 *   xml_operation("replace", &op)
 * @endcode
 */
int
xml_operation(char                *opstr, 
	      enum operation_type *op)
{
    if (strcmp("merge", opstr) == 0)
	*op = OP_MERGE;
    else if (strcmp("replace", opstr) == 0)
	*op = OP_REPLACE;
    else if (strcmp("create", opstr) == 0)
	*op = OP_CREATE;
    else if (strcmp("delete", opstr) == 0)
	*op = OP_DELETE;
    else if (strcmp("remove", opstr) == 0)
	*op = OP_REMOVE;
    else if (strcmp("none", opstr) == 0)
	*op = OP_NONE;
    else{
	clicon_err(OE_XML, 0, "Bad-attribute operation: %s", opstr);
	return -1;
    }
    return 0;
}

/*! Map xml operation from enumeration to string
 * @param[in]   op   enumeration operation, eg OP_MERGE,...
 * @retval      str  String, eg "merge". Static string, no free necessary
 * @code
 *   enum operation_type op;
 *   xml_operation("replace", &op)
 * @endcode
 */
char *
xml_operation2str(enum operation_type op)
{
    switch (op){
    case OP_MERGE:
	return "merge";
	break;
    case OP_REPLACE:
	return "replace";
	break;
    case OP_CREATE:
	return "create";
	break;
    case OP_DELETE:
	return "delete";
	break;
    case OP_REMOVE:
	return "remove";
	break;
    default:
	return "none";
    }
}
/*! Map xml insert attribute from string to enumeration
 * @param[in]   instr String, eg "first"
 * @param[out]  ins   Enumeration, eg INS_FIRST
 * @code
 *   enum insert_type ins;
 *   xml_operation("last", &ins)
 * @endcode
 */
int
xml_attr_insert2val(char             *instr, 
		    enum insert_type *ins)
{
    if (strcmp("first", instr) == 0)
	*ins = INS_FIRST;
    else if (strcmp("last", instr) == 0)
	*ins = INS_LAST;
    else if (strcmp("before", instr) == 0)
	*ins = INS_BEFORE;
    else if (strcmp("after", instr) == 0)
	*ins = INS_AFTER;
    else{
	clicon_err(OE_XML, 0, "Bad-attribute operation: %s", instr);
	return -1;
    }
    return 0;
}

/*! Specialization of clicon_debug with xml tree 
 * @param[in]  level    log level, eg LOG_DEBUG,LOG_INFO,...,LOG_EMERG. 
 * @param[in]  x        XML tree that is logged without prettyprint
 * @param[in]  format   Message to print as argv.
*/
int
clicon_log_xml(int    level, 
	       cxobj *x,
	       char  *format, ...)
{
    va_list args;
    int     len;
    char   *msg = NULL;
    cbuf   *cb = NULL;
    int     retval = -1;

    /* Print xml as cbuf */
    if ((cb = cbuf_new()) == NULL){
	clicon_err(OE_XML, errno, "cbuf_new");
	goto done;
    }
    if (clicon_xml2cbuf(cb, x, 0, 0, -1) < 0)
	goto done;
    
    /* first round: compute length of debug message */
    va_start(args, format);
    len = vsnprintf(NULL, 0, format, args);
    va_end(args);
    
    /* allocate a message string exactly fitting the message length */
    if ((msg = malloc(len+1)) == NULL){
	fprintf(stderr, "malloc: %s\n", strerror(errno)); /* dont use clicon_err here due to recursion */
	goto done;
    }

    /* second round: compute write message from format and args */
    va_start(args, format);
    if (vsnprintf(msg, len+1, format, args) < 0){
	va_end(args);
	fprintf(stderr, "vsnprintf: %s\n", strerror(errno)); /* dont use clicon_err here due to recursion */
	goto done;
    }
    va_end(args);

    /* Actually log it */
    clicon_log(level, "%s: %s", msg, cbuf_get(cb));

    retval = 0;
  done:
    if (cb)
	cbuf_free(cb);
    if (msg)
	free(msg);
    return retval;
}

#ifdef XML_EXPLICIT_INDEX
/*
 *
 */

/*! Is this XML object a search index, ie it is registered as a yang clixon cc:search_index
 * Is this xml node a search index and does it have a parent that is a list and a grandparent 
 * where a search-vector can be placed
 * @param[in] x  XML object
 * @retval    1  Yes
 * @retval    0  No
 */
int
xml_search_index_p(cxobj *x)
{
    yang_stmt *y;
    cxobj     *xp;
    
    /* The index variable has a yang spec */
    if ((y = xml_spec(x)) == NULL)
	return 0;
    /* The index variable is a registered search index */
    if (yang_flag_get(y, YANG_FLAG_INDEX) == 0)
	return 0;
    /* The index variable has a parent which has a LIST yang spec  */
    if ((xp = xml_parent(x)) == NULL)
	return 0;
    if ((y = xml_spec(xp)) == NULL)
	return 0;
    if (yang_keyword_get(y) != Y_LIST)
	return 0;
    /* The index variable has a grand-parent */
    if (xml_parent(xp) == NULL)
	return 0;
    return 1;
}
	

/*! Free all search vector pairs of this XML node
 * @param[in]  x    XML object
 * @retval     0    OK
 * @retval    -1    Error
 */
static int
xml_search_index_free(cxobj *x)
{
    struct search_index *si;

    while ((si = x->x_search_index) != NULL) {
	DELQ(si, x->x_search_index, struct search_index *);
	if (si->si_name)
	    free(si->si_name);
	if (si->si_xvec)
	    clixon_xvec_free(si->si_xvec);
	free(si);
    }
    return 0;
}

/*! Add single search vector pair to this XML node
 * @param[in]  x     XML object
 * @param[in]  name  Name of index variable
 * @retval     0     OK
 * @retval    -1     Error
 */
static struct search_index *
xml_search_index_add(cxobj *x,
		     char  *name)
{
    struct search_index *si = NULL;

    if ((si = malloc(sizeof(struct search_index))) == NULL){
	clicon_err(OE_XML, errno, "malloc");
	goto done;
    }
    memset(si, 0, sizeof(struct search_index));
    if ((si->si_name = strdup(name)) == NULL){
	clicon_err(OE_XML, errno, "strdup");
	free(si);
	si = NULL;
	goto done;
    }
    if ((si->si_xvec = clixon_xvec_new()) == NULL){
	free(si->si_name);
	free(si);
	si = NULL;
	goto done;
    }
    ADDQ(si, x->x_search_index);
 done:
    return si;
}

/*! Add single search vector pair to this XML node
 * @param[in]  x     XML object
 * @param[in]  name  Name of index variable
 * @retval     0     OK
 * @retval    -1     Error
 */
static struct search_index *
xml_search_index_get(cxobj *x,
		     char  *name)
{
    struct search_index *si = NULL;

    if ((si = x->x_search_index) != NULL) {
	do {
	    if (strcmp(si->si_name, name) == 0){
		goto done;
		break;
	    }
	    si = NEXTQ(struct search_index *, si);
	} while (si && si != x->x_search_index);
    }
 done:
    return si;
}

/*--------------------------------------------------*/

/*! Get sorted index vector for list for variable "name"
 * @param[in]  xp    XML parent object
 * @param[in]  name  Name of index variable
 * @param[out] xvec  XML object search vector
 * @retval     0     OK
 */
int
xml_search_vector_get(cxobj        *xp,
		      char         *name,
		      clixon_xvec **xvec)
{
    struct search_index *si;

    *xvec = NULL;
    if ((si = xp->x_search_index) != NULL) {
	do {
	    if (strcmp(si->si_name, name) == 0){
		*xvec = si->si_xvec;
		break;
	    }
	    si = NEXTQ(struct search_index *, si);
	} while (si && si != xp->x_search_index);
    }
    return 0;
}

/*! Insert a new cxobj into search index vector for list for variable "name"
 * @param[in] xp XML parent object (the list element)
 * @param[in] xi XML index object (that should be added)
 */
int
xml_search_child_insert(cxobj *xp,
			cxobj *xi)
{
    int                  retval = -1;
    char                *indexvar;
    struct search_index *si;
    cxobj               *xpp;
    int                  i;
    int                  len;
    
    indexvar = xml_name(xi);
    if ((xpp = xml_parent(xp)) == NULL)
	goto ok;
    /* Find base vector in grandparent */
    if ((si = xml_search_index_get(xpp, indexvar)) == NULL){
	/* If not found add base vector in grand-parent */	      
	if ((si = xml_search_index_add(xpp, indexvar)) == NULL)
	    goto done;
    }
    /* Find element position using binary search and then remove */
    len = clixon_xvec_len(si->si_xvec);
    if ((i = xml_search_indexvar_binary_pos(xp, indexvar, si->si_xvec, 0, len, len, NULL)) < 0)
	goto done;
    assert(clixon_xvec_i(si->si_xvec, i) != xp);
    if (clixon_xvec_insert_pos(si->si_xvec, xp, i) < 0)
	goto done;
 ok:
    retval = 0;
 done:    
    return retval;
}

/*! Remove a single cxobj from search vector 
 * @param[in] xp  XML parent object (the list element)
 * @param[in] xi  XML index object (that should be added)
 */
int
xml_search_child_rm(cxobj *xp,
		    cxobj *xi)
{
    int                 retval = -1;
    cxobj              *xpp;
    char               *indexvar;
    int                 i;
    int                 len;
    struct search_index *si;
    int                  eq = 0;
    
    indexvar = xml_name(xi);
    if ((xpp = xml_parent(xp)) == NULL)
	goto ok;
    /* Find base vector in grandparent */
    if ((si = xml_search_index_get(xpp, indexvar)) == NULL)
	goto ok;
    
    /* Find element using binary search and then remove */
    len = clixon_xvec_len(si->si_xvec);
    if ((i = xml_search_indexvar_binary_pos(xp, indexvar, si->si_xvec, 0, len, len, &eq)) < 0)
	goto done;
	//    if (clixon_xvec_i(si->si_xvec, i) == xp)
    if (eq)
	if (clixon_xvec_rm_pos(si->si_xvec, i) < 0)
	    goto done;		
 ok:
    retval = 0;
 done:
    return retval;
}

#endif /* XML_EXPLICIT_INDEX */
