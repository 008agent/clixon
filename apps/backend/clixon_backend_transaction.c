/*
 *
  Copyright (C) 2009-2016 Olof Hagsand and Benny Holmgren

  This file is part of CLIXON.

  CLIXON is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 3 of the License, or
  (at your option) any later version.

  CLIXON is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with CLIXON; see the file LICENSE.  If not, see
  <http://www.gnu.org/licenses/>.

 */
/*
 * Note that the functions in this file are accessible from the plugins
 */
#ifdef HAVE_CONFIG_H
#include "clixon_config.h" /* generated by config & autoconf */
#endif

#include <stdio.h>
#include <stdarg.h>
#include <string.h>
#include <stdlib.h>
#include <inttypes.h>
#include <dirent.h>
#include <errno.h>
#include <ctype.h>
#include <sys/types.h>
#include <regex.h>
#include <netinet/in.h>

/* cligen */
#include <cligen/cligen.h>

/* clicon */
#include <clixon/clixon.h>

#include "clixon_backend_transaction.h"
#include "backend_plugin.h"

/* Access functions for transaction-data handle in callbacks
 * Expressed in a transition from an current -> wanted state.
 * For example, adding a database symbol 'a' in candidate and commiting
 * would give running in source and 'a' and candidate in 'target'.
 */
/*! Get transaction id
 * @param[in]  td   transaction_data
 * @retval     id   transaction id
 */
uint64_t
transaction_id(transaction_data td)
{
    return ((transaction_data_t *)td)->td_id;
}

/*! Get plugin/application specific callbackargument
 * @param[in]  td   transaction_data
 * @retval     arg  callback argument
 * @note NYI
 */
void *
transaction_arg(transaction_data td)
{
  return ((transaction_data_t *)td)->td_arg;
}

/*! Get Source database xml tree
 * @param[in]  td   transaction_data
 * @retval     src  source xml tree containing original state
 */
cxobj *
transaction_src(transaction_data td)
{
  return ((transaction_data_t *)td)->td_src;
}

/*! Get target database xml tree
 * @param[in]  td   transaction_data
 * @retval     xml  target xml tree containing wanted state
 */
cxobj *
transaction_target(transaction_data td)
{
  return ((transaction_data_t *)td)->td_target;
}

/*! Get delete xml vector, ie vector of xml nodes that are deleted src->target
 * @param[in]  td   transaction_data
 * @retval     vec  Vector of xml nodes
 */
cxobj **
transaction_dvec(transaction_data td)
{
  return ((transaction_data_t *)td)->td_dvec;
}

/*! Get length of delete xml vector
 * @param[in]  td   transaction_data
 * @retval     len  Length of vector of xml nodes
 * @see transaction_dvec
 */
size_t
transaction_dlen(transaction_data td)
{
  return ((transaction_data_t *)td)->td_dlen;
}

/*! Get add xml vector, ie vector of xml nodes that are added src->target
 * @param[in]  td   transaction_data
 * @retval     vec  Vector of xml nodes
 */
cxobj **
transaction_avec(transaction_data td)
{
  return ((transaction_data_t *)td)->td_avec;
}

/*! Get length of add xml vector
 * @param[in]  td   transaction_data
 * @retval     len  Length of vector of xml nodes
 * @see transaction_avec
 */
size_t
transaction_alen(transaction_data td)
{
  return ((transaction_data_t *)td)->td_alen;
}

/*! Get source changed xml vector, ie vector of xml nodes that changed
 * @param[in]  td    transaction_data
 * @retval     vec   Vector of xml nodes
 * These are only nodes of type LEAF. 
 * For each node in this vector which contains the original value, there
 * is a node in tcvec with the changed value
 * @see transaction_dcvec
 */
cxobj **
transaction_scvec(transaction_data td)
{
  return ((transaction_data_t *)td)->td_scvec;
}

/*! Get target changed xml vector, ie vector of xml nodes that changed
 * @param[in]  td    transaction_data
 * @retval     vec   Vector of xml nodes
 * These are only nodes of type LEAF. 
 * For each node in this vector which contains the original value, there
 * is a node in tcvec with the changed value
 * @see transaction_scvec
 */
cxobj **
transaction_tcvec(transaction_data td)
{
  return ((transaction_data_t *)td)->td_dvec;
}

/*! Get length of changed xml vector
 * @param[in]  td   transaction_data
 * @retval     len Length of vector of xml nodes
 * This is the length of both the src change vector and the target change vector
 */
size_t
transaction_clen(transaction_data td)
{
  return ((transaction_data_t *)td)->td_clen;
}

int
transaction_print(FILE               *f,
		  transaction_data   th)
{
    cxobj *xn;
    int i;
    transaction_data_t *td;

    td = (transaction_data_t *)th;

    fprintf(f, "Transaction id: 0x%" PRIu64 "\n", td->td_id);
    fprintf(f, "Removed\n=========\n");
    for (i=0; i<td->td_dlen; i++){
	xn = td->td_dvec[i];
	clicon_xml2file(f, xn, 0, 1);
    }
    fprintf(f, "Added\n=========\n");
    for (i=0; i<td->td_alen; i++){
	xn = td->td_avec[i];
	clicon_xml2file(f, xn, 0, 1);
    }
    fprintf(stderr, "Changed\n=========\n");
    for (i=0; i<td->td_clen; i++){
	xn = td->td_scvec[i];
	clicon_xml2file(f, xn, 0, 1);
	xn = td->td_tcvec[i];
	clicon_xml2file(f, xn, 0, 1);
    }
    return 0;
}
