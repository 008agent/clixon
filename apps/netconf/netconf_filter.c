/*
 *
  Copyright (C) 2009-2016 Olof Hagsand and Benny Holmgren

  This file is part of CLICON.

  CLICON is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 3 of the License, or
  (at your option) any later version.

  CLICON is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with CLICON; see the file LICENSE.  If not, see
  <http://www.gnu.org/licenses/>.

 *
 *  netconf match & selection: get and edit operations
 *****************************************************************************/
#ifdef HAVE_CONFIG_H
#include "clicon_config.h" /* generated by config & autoconf */
#endif

#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <stdlib.h>
#include <errno.h>
#include <signal.h>
#include <fcntl.h>
#include <time.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/param.h>
#include <assert.h>

/* cligen */
#include <cligen/cligen.h>

/* clicon */
#include <clicon/clicon.h>

#include "netconf_rpc.h"
#include "netconf_lib.h"
#include "netconf_filter.h"

/*
 * xml_filter
 * xf specifices a filter, and xn is an xml tree.
 * Select the part of xn that matches xf and return it.
 * Change xn destructively by removing the parts of the sub-tree that does 
 * not match.
 * Match according to Section 6 of RFC 4741.
    NO_FILTER,       select all 
    EMPTY_FILTER,    select nothing 
    ATTRIBUTE_MATCH, select if attribute match 
    SELECTION,       select this node 
    CONTENT_MATCH,   select all siblings with matching content 
    CONTAINMENT      select 
 */

/* return a string containing leafs value, NULL if no leaf or no value */
static char*
leafstring(cxobj *x)
{
    cxobj *c;

    if (xml_type(x) != CX_ELMNT)
	return NULL;
    if (xml_child_nr(x) != 1)
	return NULL;
    c = xml_child_i(x, 0);
    if (xml_child_nr(c) != 0)
	return NULL;
    if (xml_type(c) != CX_BODY)
	return NULL;
    return xml_value(c);
}

/*! Internal recursive part where configuration xml tree is pruned frim filter
 * assume parent has been selected and filter match (same name) as parent
 * parent is pruned according to selection.
 * @param[in]  xfilter  Filter xml
 * @param[out] xconf    Configuration xml
 * @retval  0  OK
 * @retval -1  Error
 */
static int
xml_filter2(cxobj *xfilter, 
	    cxobj *xparent, 
	    int   *remove_me)
{
    cxobj *s;
    cxobj *sprev;
    cxobj *f;
    cxobj *attr;
    char *an;
    char *af;
    char *fstr;
    char *sstr;
    int   containments;
    int   remove_s;

    *remove_me = 0;
    assert(xfilter && xparent && strcmp(xml_name(xfilter), xml_name(xparent))==0);
    /* 1. Check selection */
    if (xml_child_nr(xfilter) == 0) 
	goto match;

    /* Count containment/selection nodes in filter */
    f = NULL;
    containments = 0;
    while ((f = xml_child_each(xfilter, f, CX_ELMNT)) != NULL) {
	if (leafstring(f))
	    continue;
	containments++;
    }

    /* 2. Check attribute match */
    attr = NULL;
    while ((attr = xml_child_each(xfilter, attr, CX_ATTR)) != NULL) {
	af = xml_value(attr);
	an = xml_find_value(xfilter, xml_name(attr));
	if (af && an && strcmp(af, an)==0)
	    ; // match
	else
	    goto nomatch;
    }
    /* 3. Check content match */
    f = NULL;
    while ((f = xml_child_each(xfilter, f, CX_ELMNT)) != NULL) {
	if ((fstr = leafstring(f)) == NULL)
	    continue;
	if ((s = xml_find(xparent, xml_name(f))) == NULL)
	    goto nomatch;
	if ((sstr = leafstring(s)) == NULL)
	    continue;
	if (strcmp(fstr, sstr))
	    goto nomatch;
    }
    /* If filter has no further specifiers, accept */
    if (!containments)
	goto match;
    /* Check recursively the rest of the siblings */
    sprev = s = NULL;
    while ((s = xml_child_each(xparent, s, CX_ELMNT)) != NULL) {
	if ((f = xml_find(xfilter, xml_name(s))) == NULL){
	    xml_prune(xparent, s, 1);
	    s = sprev;
	    continue;
	}
	if (leafstring(f)){
	    sprev = s;
	    continue; // unsure?sk=lf
	}
	// XXX: s can be removed itself in the recursive call !
	remove_s = 0;
	if (xml_filter2(f, s, &remove_s) < 0)
	    return -1;
	if (remove_s){
	    xml_prune(xparent, s, 1);
	    s = sprev;
	}
	sprev = s;
    }

  match:
    return 0;
  nomatch: /* prune this parent node (maybe only children?) */
    *remove_me = 1;
    return 0;
}

/*! Remove parts of configuration xml tree that does not match filter xml tree
 * @param[in]  xfilter  Filter xml
 * @param[out] xconf    Configuration xml
 * @retval  0  OK
 * @retval -1  Error
 * This is the top-level function, calls a recursive variant.
 */
int
xml_filter(cxobj *xfilter, 
	   cxobj *xconfig)
{
    int retval;
    int remove_s;

    /* Call recursive variant */
    retval = xml_filter2(xfilter, 
			 xconfig, 
			 &remove_s);
    return retval;
}

